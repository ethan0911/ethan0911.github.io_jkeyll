<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-07-13T10:38:33-06:00</updated><id>http://localhost:4000/</id><title type="html">Feng Wang</title><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><entry><title type="html">Comments in LaTeX</title><link href="http://localhost:4000/latex/2018/07/10/comments-in-latex" rel="alternate" type="text/html" title="Comments in LaTeX" /><published>2018-07-10T00:00:00-06:00</published><updated>2018-07-10T00:00:00-06:00</updated><id>http://localhost:4000/latex/2018/07/10/comments-in-latex</id><content type="html" xml:base="http://localhost:4000/latex/2018/07/10/comments-in-latex">&lt;p&gt;When writing a paper in LaTeX, it’s common to leave
notes and comments in the text, either to yourself
or your co-authors. I used to write these
as just different colored text using &lt;code class=&quot;highlighter-rouge&quot;&gt;\textcolor{...}&lt;/code&gt;,
with each author assigned a color, or all with the same color.
However, with more authors
it can get hard to keep picking legible font colors.
Futhermore, sometimes just a different color font doesn’t
stand out quite as much as I’d like from the rest of the text.
More recently I’ve switched to using highlights for
the comments, which works well with multiple authors,
and helps the comments stand out from the rest of
the text. This is easy to do with the
&lt;a href=&quot;https://ctan.org/pkg/soul?lang=en&quot;&gt;soul&lt;/a&gt; and
&lt;a href=&quot;https://ctan.org/pkg/xcolor?lang=en&quot;&gt;xcolor&lt;/a&gt; packages.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;The soul package lets you highlight text, while
the xcolor package provides some convenient color names
(I use it with the dvipsnames option). With these packages
you can then create commands for each author to write
their comments as &lt;code class=&quot;highlighter-rouge&quot;&gt;\authorname{comment}&lt;/code&gt;, as shown below.
This sample is also available on
&lt;a href=&quot;https://www.overleaf.com/read/nsxknypvpfhh&quot;&gt;Overleaf&lt;/a&gt;, so
you see it in action.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-latex&quot; data-lang=&quot;latex&quot;&gt;&lt;span class=&quot;k&quot;&gt;\documentclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;article&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[utf8]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;inputenc&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;soul&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[dvipsnames]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;xcolor&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;% We also use DeclareRobustCommand instead of&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;% NewCommand so that the command will work in captions&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;% and other contexts as well.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\DeclareRobustCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\will&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;[1]&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\begingroup\sethlcolor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;BurntOrange&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\hl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;(will:) #1&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\endgroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;\begin{document}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;% The highlight comment command can then be used in the text&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\will&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;This is an example comment!&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;\begin{figure}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;% Or in captions, etc.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\caption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\will&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;By making it robust, we can also use it in captions.&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;\end{figure}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;\end{document}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="latex" /><category term="latex" /><summary type="html">When writing a paper in LaTeX, it’s common to leave notes and comments in the text, either to yourself or your co-authors. I used to write these as just different colored text using \textcolor{...}, with each author assigned a color, or all with the same color. However, with more authors it can get hard to keep picking legible font colors. Futhermore, sometimes just a different color font doesn’t stand out quite as much as I’d like from the rest of the text. More recently I’ve switched to using highlights for the comments, which works well with multiple authors, and helps the comments stand out from the rest of the text. This is easy to do with the soul and xcolor packages.</summary></entry><entry><title type="html">Volume Rendering with WebGL</title><link href="http://localhost:4000/webgl/2018/07/01/volume-rendering-with-webgl" rel="alternate" type="text/html" title="Volume Rendering with WebGL" /><published>2018-07-01T00:00:00-06:00</published><updated>2018-07-01T00:00:00-06:00</updated><id>http://localhost:4000/webgl/2018/07/01/volume-rendering-with-webgl</id><content type="html" xml:base="http://localhost:4000/webgl/2018/07/01/volume-rendering-with-webgl">&lt;figure&gt;
	&lt;img class=&quot;img-fluid&quot; src=&quot;https://i.imgur.com/YqdyKCj.png&quot; /&gt;
	&lt;figcaption&gt;&lt;i&gt;Fig. 1: Sample volumes CAP TODO&lt;/i&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In scientific visualization, volume rendering is used to visualize
3D scalar fields. These scalar fields are often
uniform grids of values, representing,
e.g., charge density around a molecule,
an MRI scan, air pressure around an airplane, etc.
Volume rendering is a conceptually straightforward method
for turning such data into an image: by sampling the data
along rays from the eye and applying
a color and transparency value to each point we can
produce useful and beautiful images of such scalar fields.
While previous WebGL1 implementations had to work around
the lack of 3D texture support, this is no longer
the case with WebGL2. Using WebGL2 we can implement
an elegant and fast volume renderer in the browser,
to deliver interactive volume visualization to users.
We’ll discuss the mathematical background
for volume rendering, and how it can be implemented using
WebGL2 to create an
&lt;a href=&quot;https://www.willusher.io/webgl-volume-raycaster/&quot;&gt;interactive volume renderer&lt;/a&gt;
entirely in the browser!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h1&gt;

&lt;p&gt;What is volume rendering?&lt;/p&gt;

&lt;p&gt;\[
C(r) = \int_0^L C(s) \mu(s) e^{-\int_0^s \mu(t) dt} ds
\]&lt;/p&gt;

&lt;h1 id=&quot;11-webgl-2&quot;&gt;1.1 WebGL 2&lt;/h1&gt;

&lt;p&gt;Something about recent 3D textures, maybe skip this entirely?&lt;/p&gt;

&lt;h1 id=&quot;2-webgl2-implementation&quot;&gt;2. WebGL2 Implementation&lt;/h1&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="webgl" /><category term="webgl" /><category term="javascript" /><summary type="html">Fig. 1: Sample volumes CAP TODO In scientific visualization, volume rendering is used to visualize 3D scalar fields. These scalar fields are often uniform grids of values, representing, e.g., charge density around a molecule, an MRI scan, air pressure around an airplane, etc. Volume rendering is a conceptually straightforward method for turning such data into an image: by sampling the data along rays from the eye and applying a color and transparency value to each point we can produce useful and beautiful images of such scalar fields. While previous WebGL1 implementations had to work around the lack of 3D texture support, this is no longer the case with WebGL2. Using WebGL2 we can implement an elegant and fast volume renderer in the browser, to deliver interactive volume visualization to users. We’ll discuss the mathematical background for volume rendering, and how it can be implemented using WebGL2 to create an interactive volume renderer entirely in the browser!</summary></entry><entry><title type="html">Distributed Rendering with Rust and Mio</title><link href="http://localhost:4000/2016/01/02/distributed-rendering-with-rust-and-mio" rel="alternate" type="text/html" title="Distributed Rendering with Rust and Mio" /><published>2016-01-02T00:00:00-07:00</published><updated>2016-01-02T00:00:00-07:00</updated><id>http://localhost:4000/2016/01/02/distributed-rendering-with-rust-and-mio</id><content type="html" xml:base="http://localhost:4000/2016/01/02/distributed-rendering-with-rust-and-mio">&lt;p&gt;In this post we’ll take a look at adding distributed rendering to
&lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt; which will let us take advantage of multiple
machines when rendering an image, like a compute cluster.
To do this we’ll look at options for how to distribute the rendering job across multiple nodes
and what sort of communication is needed synchronize their work. We’ll also look into how we
can use &lt;a href=&quot;https://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; to write an efficient master process that
can manage multiple workers effectively.&lt;/p&gt;

&lt;p&gt;After implementing a simple technique to distribute the job we’ll discuss
the scalability of this approach and possible paths forward to improve it. I’ve
also recently written a &lt;a href=&quot;https://github.com/Twinklebear/tray_rust_blender&quot;&gt;plugin for Blender&lt;/a&gt; so you can
easily create your own scenes and
will mention a bit on how to run the ray tracer on Google Compute Engine (or AWS EC2)
if you want to try out the distributed rendering yourself.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;distributing-work-in-a-ray-tracer&quot;&gt;Distributing Work in a Ray Tracer&lt;/h1&gt;

&lt;p&gt;To motivate how to distribute the rendering job between nodes it’s worth a short review
of how work is distributed between threads on a single machine.&lt;/p&gt;

&lt;h2 id=&quot;work-distribution-between-threads&quot;&gt;Work Distribution Between Threads&lt;/h2&gt;

&lt;p&gt;Since all the work
of tracing a ray through a pixel and into the scene is independent for each pixel a simple approach
is to split the image up into blocks, let’s say 8x8, and assign these blocks
to different threads to render. We end up with a simple queue of blocks to be rendered and track the
next one to hand out with an atomic counter. When a thread wants a new block to render it just
increments the counter and fetches the next block, or sees that there are none left and exits. Choosing a
block size bigger than 1x1 (a single pixel) but not too big gives a nice trade off between load balancing
blocks and synchronization overhead when a thread gets its next block.
In an attempt to get some cache-coherence the block queue is sorted in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Z-order_curve&quot;&gt;Z-order&lt;/a&gt; so it’s more likely a thread will pick a
block closer to what it and other threads are working on, giving a higher chance the meshes
and other data for that region are already in cache.&lt;/p&gt;

&lt;div class=&quot;col-md-12&quot;&gt;
&lt;div class=&quot;col-md-8 offset-md-2 text-md-center&quot;&gt;
&lt;pre class=&quot;diagram&quot;&gt;
                +----------+----------+
                |          |          |
                |          |          |
   Given to ---&amp;gt;+ block 0  | block 1  |&amp;lt;--- Given to
   thread 0     |        --+-.        |     thread 1
                |          |/         |
                +----------/----------+
                |         /|          |
                |        '-+--        |
 Next block ---&amp;gt;| block 2  | block 3  |
 to give out    |          |          |
                |          |          |
                +----------+----------+
&lt;/pre&gt;
&lt;i&gt;Distributing blocks in Z-order for a 16x16 image rendered with two threads.
Diagrams generated with &lt;a href=&quot;http://casual-effects.com/markdeep/&quot;&gt;Markeep&lt;/a&gt;.&lt;/i&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Saving the sampled color data from a ray in this system is also relatively simple, but requires a bit of
synchronization to handle &lt;a href=&quot;http://www.luxrender.net/wiki/LuxRender_Render_settings#Filter&quot;&gt;reconstruction filtering&lt;/a&gt;.
When using a reconstruction filter the sample
computed by a ray is written to multiple pixels, weighted by the filter weight at each pixel.
Threads must synchronize their writes since the blocks of pixels they’re writing to are not disjoint even
though the blocks they’re assigned are.
This synchronization is handled with a fine-grained locking scheme, where each 2x2 block of pixels
in the framebuffer is protected by a mutex that the thread must acquire before writing its samples to that
region of the framebuffer. Without reconstruction filtering threads never write to the same pixel since
their work regions are disjoint and we wouldn’t need any synchronization, however the quality improvement
from reconstruction filtering is worth the added overhead.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; A pixel in the framebuffer isn’t an 8-bit RGB triple since we need
the filter weight of each pixel accumulated from samples written to it.
A pixel is four floats, an RGB triple and the accumulated filter weight.
To save the image we divide the RGB components by the filter weight and convert to
8-bit sRGB. Without storing the floating point samples we wouldn’t be able
to correctly reconstruct the image when taking multiple samples per pixel and/or using reconstruction
filtering.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;extending-to-multiple-machines&quot;&gt;Extending to Multiple Machines&lt;/h2&gt;

&lt;p&gt;This image based work decomposition extends easily to distributing work across multiple
machines. Instead of having a single node work through the block queue we assign
subsets of it to different machines in our cluster, where they will distribute
their blocks to threads for rendering as before. By adding the reasonable
assumption that the scene data is on some shared filesystem or has already been uploaded to each
machine we can send a simple set of instructions to each worker. All we need to tell them
is where to find the scene file, which frames of the animation to render and what subset of blocks
they’ve been assigned.&lt;/p&gt;

&lt;p&gt;Suppose we’re rendering a 400x304 image of the scene “cornell_box.json” with five
worker nodes. In total we have 1900 8x8 blocks to render and the master
will instruct each node to render 380 of them. In the case that
the number of nodes doesn’t evenly divide the number of blocks the remainder are given to the
last worker.&lt;/p&gt;

&lt;div class=&quot;col-md-12 text-md-center&quot;&gt;
&lt;pre class=&quot;diagram&quot;&gt;
       .-------------------------.      .---------.       .-------------------------.       
      | Scene: &quot;cornell_box.json&quot; |     |         |      | Scene: &quot;cornell_box.json&quot; |      
      | Frames: (0, 0)            |     | Master  |      | Frames: (0, 0)            |      
      | Block Start: 0            |     +---------+      | Block Start: 1520         |      
      | Block Count: 380          |    /// ----- \\\     | Block Count: 380          |      
       '-----------+-------------'    '--+-+-+-+-+--'     '--------+----------------'       
                   |                     | | | | |                 |                        
              .----o--------------------'  | | |  '----------------o--------.               
             |                .-----------'  |  '-----------.                |              
             |               |               |               |               |              
             v               v               v               v               v              
         .---+----.      .---+----.      .---+----.      .---+----.      .---+----.         
        /        /|     /        /|     /        /|     /        /|     /        /|         
       +--------+/|    +--------+/|    +--------+/|    +--------+/|    +--------+/|         
       |        +/|    |        +/|    |        +/|    |        +/|    |        +/|         
       | Worker +/|    | Worker +/|    | Worker +/|    | Worker +/|    | Worker +/|         
       | node 0 +/|    | node 1 +/|    | node 2 +/|    | node 3 +/|    | node 4 +/|         
       |        +/     |        +/     |        +/     |        +/     |        +/          
       '--------'      '--------'      '--------'      '--------'      '--------'           
&lt;/pre&gt;
&lt;i&gt;Master sends instructions to the worker nodes&lt;/i&gt;
&lt;/div&gt;

&lt;h3 id=&quot;combining-results-from-workers&quot;&gt;Combining Results from Workers&lt;/h3&gt;

&lt;p&gt;We’re left with one small issue when combining results from our worker nodes, and it relates
to why we need store floating point sample data and deal with locking our framebuffer to synchronize it
between threads on a node. Although the regions assigned to workers are disjoint subsets of the
image the samples that their threads compute will overlap with neighboring nodes due to reconstruction
filtering. For example, if we use a 4x4 pixel filter each node
will write to its 8x8 blocks and +/- 2 pixels in each direction, overlapping with other worker’s regions.&lt;/p&gt;

&lt;p&gt;In our example rendering of the Cornell box the images below would be the results of each worker if
we just saved them out. If you zoom in a bit you can see there’s some overlap between the regions written to by
each worker. The images are a bit noisy since they were rendered with just 256 samples per pixel.
Note that with the Mitchell-Netravali
filter used here some pixels are actually assigned negative weights so these won’t show up properly in the
images below. Additionally, there may also be a bug causing the odd extra boxes at the corners of the worker’s
results, I need to look into this some more.&lt;/p&gt;

&lt;div class=&quot;row&quot;&gt;
&lt;div class=&quot;col-md-6 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/9UfVGse.png&quot; alt=&quot;Node 0's results&quot; /&gt;
&lt;i&gt;Worker 0's Results&lt;/i&gt;
&lt;/div&gt;
&lt;div class=&quot;col-md-6 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/1PrdC7N.png&quot; alt=&quot;node 1's results&quot; /&gt;
&lt;i&gt;Worker 1's Results&lt;/i&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;row&quot;&gt;
&lt;div class=&quot;col-md-4 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/NKXW7ap.png&quot; alt=&quot;node 2's results&quot; /&gt;
&lt;i&gt;Worker 2's Results&lt;/i&gt;
&lt;/div&gt;

&lt;div class=&quot;col-md-4 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/lF8jwRE.png&quot; alt=&quot;node 3's results&quot; /&gt;
&lt;i&gt;Worker 3's Results&lt;/i&gt;
&lt;/div&gt;

&lt;div class=&quot;col-md-4 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/Qz7yIyL.png&quot; alt=&quot;node 4's results&quot; /&gt;
&lt;i&gt;Worker 4's Results&lt;/i&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Due to this overlap the master node needs to be able to properly combine pixels from multiple nodes.
This requires that each worker sends its pixels as the full float RGB triple and filter weight that
we mentioned earlier.&lt;/p&gt;

&lt;h3 id=&quot;reducing-communication-overhead&quot;&gt;Reducing Communication Overhead&lt;/h3&gt;

&lt;p&gt;Since most of the worker’s framebuffer will be black as other nodes are assigned those regions there’s no
reason to send the whole thing. This significantly reduces communication overhead, sending the full
framebuffer would significantly increase the data transferred as we added more nodes which will hurt scalability.
Consider rendering a 1920x1080 image: each node sends the master a RGBW float framebuffer
for a total of about 32MB per node. If we used 64 nodes to render this we’d send a total of about 2.05GB,
where only about 1.56% of each 32MB framebuffer sent by the workers has actually been written too!&lt;/p&gt;

&lt;p&gt;Since the worker only writes to a small portion of the framebuffer we can just send the blocks that it’s
actually written too.
For convenience I currently send blocks of the same size as the framebuffer locks, so each worker will send
a list of 2x2 blocks along with a list of where the blocks are in the image. This significantly reduces
communication overhead and provides the master with all the information it needs to place a worker’s results
in the final framebuffer. This does add some overhead to each block: we send the x,y coordinates of the
block as unsigned 64-bit ints which adds a 16 byte header to each 2x2 block (64 bytes of pixel data) for
a 25% overhead per block.&lt;/p&gt;

&lt;p&gt;We do still add some additional communication as we add more nodes since the regions that nodes
send back to the master overlap some based on the size of the reconstruction filter. We’ll discuss
one idea for potentially reducing this overhead further in the scalability section.&lt;/p&gt;

&lt;div class=&quot;col-md-12 text-md-center&quot;&gt;
&lt;pre class=&quot;diagram&quot;&gt;
        .--------.      .--------.      .--------.      .--------.      .--------.      
       /        /|     /        /|     /        /|     /        /|     /        /|      
      +--------+/|    +--------+/|    +--------+/|    +--------+/|    +--------+/|      
      |        +/|    |        +/|    |        +/|    |        +/|    |        +/|      
      | Worker +/|    | Worker +/|    | Worker +/|    | Worker +/|    | Worker +/|      
      | node 0 +/|    | node 1 +/|    | node 2 +/|    | node 3 +/|    | node 4 +/|      
      |        +/     |        +/     |        +/     |        +/     |        +/       
      '----+---'      '----+---'      '----+---'      '----+---'      '----+---'        
           |               |               |               |               |            
           |               |               |               |               |            
           |               |               |               |               |            
           |                '----------.   |   .----------'                |            
            '---------o--------------.  |  |  |  .------------------------'             
                      |               | |  |  | |                                       
   .------------------+---------.     v v  v  v v                                       
  | Frame: 0                     |    .---------.                                       
  | Block Size: (2, 2)           |    |         |                                       
  | Blocks: [(0, 0), (1, 0),...] |    | Master  |                                       
  | Pixels: [8.2, 7.6, 2, 9,...] |    +---------+                                       
   '----------------------------'    /// ----- \\\                                      
                                    '------+------'                                     
                                           |                                            
                                           v                                            
                                     +-----------+                                      
                                     | Rendered  |                                      
                                     |  Image    |                                      
                                     +-----------+                                      
&lt;/pre&gt;
&lt;i&gt;Master collects rendering results from the workers and saves the image&lt;/i&gt;
&lt;/div&gt;

&lt;p&gt;Once the master has collected results from all the workers it can do the final filter weight
division for each pixel and conversion to sRGB to save the frame out as a PNG. Here’s the result
for our 400x304 Cornell box example with 256 samples per pixel that we’ve been following along.&lt;/p&gt;

&lt;div class=&quot;col-md-12 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/YEhp254.png&quot; alt=&quot;Rendered result&quot; /&gt;
&lt;i&gt;Rendered Image&lt;/i&gt;
&lt;/div&gt;

&lt;h1 id=&quot;coordinating-the-workers&quot;&gt;Coordinating the Workers&lt;/h1&gt;

&lt;p&gt;The master node requires some more work to implement than the workers, it needs to manage
accepting data from multiple workers who are reporting different regions of (potentially different) frames
of the animation and combining these results. It also needs to track whether a frame has been completed and
can be saved out to disk. Additionally we’d like the master to be as lightweight as possible so it can
run on the same node as one of the workers and not take up too much CPU.&lt;/p&gt;

&lt;p&gt;We’d also like to avoid requiring workers to open a new TCP connection each time they want to send
results to the master node. Having the master node listen on a TCP socket and behave as a blocking server
that accepts connections from workers and reads data from one at a time likely won’t scale up very well.
What we’d really like is some kind of async event loop,
where the master can wait on data from multiple workers at the same time and read from them when they’ve
sent some data.&lt;/p&gt;

&lt;h2 id=&quot;asynchronous-io-with-mio&quot;&gt;Asynchronous I/O with mio&lt;/h2&gt;

&lt;p&gt;This is where &lt;a href=&quot;https://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; comes in. Mio is a powerful low overhead I/O library
for Rust and most important for us, it provides abstractions for non-blocking TCP sockets and an event loop for
reading/writing based on whether they’re readable/writable or not. Having never used non-blocking sockets
or event based I/O this took a bit of learning but has turned out very nice.&lt;/p&gt;

&lt;p&gt;When constructing the master we can start a TCP connection to each worker,
who are all listening on the same port. The master is given the list of worker hostnames or IP addresses
specifying the worker nodes to contact. To identify the connection that an event was received on
mio allows you to specify a &lt;a href=&quot;http://rustdoc.s3-website-us-east-1.amazonaws.com/mio/master/mio/struct.Token.html&quot;&gt;Token&lt;/a&gt;
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;usize&lt;/code&gt;, we’ll just use the worker’s index in the list of workers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// Loop through the list of workers and connect to them.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// to_socket_addrs returns a Result&amp;lt;Iterator&amp;gt; of SocketAddrs, if we fail parsing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// we should just abort so we use unwrap here.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_socket_addrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Use mio's TcpStream to connect to the worker, if we succeed in starting the&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// connection add this stream to the event loop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;TcpStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Each worker is identified in the event loop by their index in the workers Vec&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_loop&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;EventSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;PollOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error registering stream from {}: {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;connections&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to contact worker {}: {:?}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After constructing the master we start running mio’s event loop. Our Master struct implements the
&lt;a href=&quot;http://rustdoc.s3-website-us-east-1.amazonaws.com/mio/master/mio/trait.Handler.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mio::Handler&lt;/code&gt;&lt;/a&gt;
trait which requires we implement the &lt;code class=&quot;highlighter-rouge&quot;&gt;ready&lt;/code&gt; method. This method is called by mio when an event
is ready to be handled on one of the TCP streams we registered with the event loop when constructing
the master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Master&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventLoop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_writable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Send the worker their instructions and stop listening for writable events&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Read frame data sent by the worker&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The writable event handling isn’t too interesting as we just send the worker their instructions
using blocking I/O. The instructions struct with the worker’s instructions is encoded
using &lt;a href=&quot;https://github.com/TyOverby/bincode&quot;&gt;bincode&lt;/a&gt; and sent
with &lt;a href=&quot;http://doc.rust-lang.org/std/io/trait.Write.html#method.write_all&quot;&gt;write_all&lt;/a&gt;. The readable
event handling is where the more interesting work of dealing with async writes from multiple workers is done.&lt;/p&gt;

&lt;h2 id=&quot;reading-from-multiple-workers-asynchronously&quot;&gt;Reading From Multiple Workers Asynchronously&lt;/h2&gt;

&lt;p&gt;While we’ve reduced the communication overhead quite a bit the workers are still going to be sending
more data than we would get with a single call to
&lt;a href=&quot;http://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read&quot;&gt;read&lt;/a&gt;, if we wanted to read the
entire frame data sent by the worker immediately upon receiving a readable event we’d still need to
block. However blocking ruins the whole reason we’ve gone with mio and async I/O in the first place!
While we’re stuck blocking on this worker there’s incoming writes from other workers that we should
also be reading from.&lt;/p&gt;

&lt;p&gt;The solution I’ve chosen here is to have a buffer for each worker that we write to each
time we get a new readable event, tracking how many bytes we’ve read so far and how many we expect to read
in total.
Each time we get a readable event on the worker we do a single &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; to get the bytes currently available
without blocking and place these in the buffer starting after the data we’ve read
previously. Once we’ve read all the bytes the worker is sending us (our data starts with an unsigned
64 bit int specifying the number sent) we can decode the frame with bincode.&lt;/p&gt;

&lt;h3 id=&quot;the-worker-buffer&quot;&gt;The Worker Buffer&lt;/h3&gt;

&lt;p&gt;A worker buffer is a partially read result from a worker, where we’re still waiting on more bytes
from the network or TCP stack. It tracks how many bytes we’re expecting to receive and how many we’ve
gotten so far so we know where to continue writing to the buffer and when we’ve got everything.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorkerBuffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currently_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorkerBuffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorkerBuffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// We start with an expected size of 8 since we expect a 64 bit uint header&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// telling us how many bytes are being sent&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WorkerBuffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currently_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The buffer stores a partially read &lt;code class=&quot;highlighter-rouge&quot;&gt;Frame&lt;/code&gt; sent back by a worker to report its results. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Frame&lt;/code&gt; struct
begins with an 8 byte header specifying how many bytes it is when encoded with bincode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Frame&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoded_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Which frame the worker is sending its results for&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Block size of the blocks being sent&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Starting locations of each block&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Sample data for each block, RGBW&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;reading-into-a-worker-buffer&quot;&gt;Reading into a Worker Buffer&lt;/h3&gt;

&lt;p&gt;When the master gets a readable event on a worker it adds the newly available bytes to the worker’s buffer
and checks if it’s read the entire &lt;code class=&quot;highlighter-rouge&quot;&gt;Frame&lt;/code&gt;. This is handled by the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_worker_buffer&lt;/code&gt; method which returns
true if we’ve got all the data the worker is sending and can decode the frame. This code is best
explained inline with comments, so please see the snippet for details on how this works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_worker_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.worker_buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// If we haven't read the size of data being sent, read that now&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// First 8 bytes are a u64 specifying the number of bytes being sent,&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// make sure we have room to store 8 bytes&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.connections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error reading results from worker {}: {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Recall that our initial expected size is 8, for the size header.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Once we've read this we can decode the header and get the real size of the data.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.expected_size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.expected_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Extend the Vec so we've got room for the remaning bytes, minus 8 for the&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// size header we just read&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.expected_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// If we've finished reading the size header we can now start reading the frame data&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.connections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error reading results from worker {}: {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Return true if we've read all the data we're expecting&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.expected_size&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the master’s event loop we call this function on readable events, passing the ID of the worker we’re
reading from.
If we’ve read the all the data being sent by the worker we decode the frame
with bincode, accumulate its data into the combined frame and clean up to start
reading the next frame.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// Read results from the worker, if we've accumulated all the data being sent&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// decode and accumulate the frame&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read_worker_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.worker_buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.save_results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Clear the worker buffer for the next frame&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.worker_buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.buf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.worker_buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.expected_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.worker_buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.currently_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;handling-workers-reporting-different-frames&quot;&gt;Handling Workers Reporting Different Frames&lt;/h3&gt;

&lt;p&gt;Due to differences in scene complexity or the worker node hardware some workers may
finish their assigned blocks faster or slower than others. The master node can’t assume that once it starts
getting frame one from a worker that all workers have reported frame zero and it can be saved out. We need
to track how many workers have reported a frame as we accumulate results from them.
Only when all workers have reported their results for a frame can we save it out and mark it completed.&lt;/p&gt;

&lt;p&gt;This is expressible very nicely with the enum type in Rust. A frame can either be in progress and we’re
tracking how many workers have reported it and the image where we’re accumulating results
or it’s completed and has been saved out.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DistributedFrame&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;InProgress&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// The number of workers who have reported results for this frame so far&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num_reporting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Where we're combining worker's results to form the final image&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Completed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DistributedFrame&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Start accumulating results for a frame, we begin with no workers reporting&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img_dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DistributedFrame&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nn&quot;&gt;DistributedFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InProgress&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_reporting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img_dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The master stores a &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&amp;lt;usize, DistributedFrame&amp;gt;&lt;/code&gt; which maps frame numbers to distributed frames
so we can quickly look up a frame when we’ve
decoded one from a worker to accumulate its results into the final image. When we try to look up
a frame in the map there’s two possibilities: the frame could be in the map (and is either &lt;code class=&quot;highlighter-rouge&quot;&gt;InProgress&lt;/code&gt;
or &lt;code class=&quot;highlighter-rouge&quot;&gt;Completed&lt;/code&gt;) or this worker is the first to report this frame and we must create the entry.&lt;/p&gt;

&lt;p&gt;This operation is performed with the hash map
&lt;a href=&quot;http://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;&lt;/a&gt; API. It’s important to note
that we use the &lt;code class=&quot;highlighter-rouge&quot;&gt;or_insert_with&lt;/code&gt; method instead of just &lt;code class=&quot;highlighter-rouge&quot;&gt;or_insert&lt;/code&gt; because starting a distributed frame
involves allocating a new image to store the result. By passing a function to call instead of a value to
insert we don’t need to start a new distributed frame each time we look one up, just when we find that
it’s not in the map.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.frames&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.or_insert_with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(||&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;DistributedFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img_dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next we handle the two cases of the entry existing in the map, either it’s in progress and we can
accumulate the results from the worker or it’s been marked completed and something has gone wrong.
If we’ve finished an in progress frame we save it to disk and mark that we’ve finished it by setting
it to &lt;code class=&quot;highlighter-rouge&quot;&gt;Completed&lt;/code&gt; outside the match. A frame is determined to be completed if the number of workers
who’ve reported results for it is equal to the total number of workers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;DistributedFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InProgress&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_reporting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Collect results from the worker and see if we've finished the&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// frame and can save it&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.add_blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.pixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_reporting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_reporting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.workers&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// This frame is done, save it out to a PNG&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;finished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;DistributedFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Completed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Worker reporting on completed frame {}?&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// This is a bit awkward, since we borrow df in the match we can't mark it completed in there&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finished&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;DistributedFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Completed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A possible improvement here is to have the job of adding the worker’s results to the distributed frame
be managed by a threadpool, or at least off load the work of saving the image to some
other threads. This would free up more time on the event loop for the master to read more data from
the workers, currently it will be busy for some time accumulating results from workers and saving
the images.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Some of the details are bit involved but overall the distributed computation is not too complicated.
The work decomposition chosen allows us to get away without any communication between the workers,
they just need to know what part of the image they’re rendering and who to send results back to. Since
we also assume that the scene data is available on each worker either through a shared file system
or by simplying being copied to each machine we don’t have to worry about sending the models and such over
either. When the
worker launches it starts listening for the master on a hard-coded port number (63234). The master
is launched and passed the worker’s hostnames or IP addresses and it
starts opening a TCP connection to each and enters mio’s event loop.&lt;/p&gt;

&lt;p&gt;Once a worker is writable (we’ve connected successfully) the master sends the worker its instructions
and stops watching for writable events on the connection. Upon recieving instructions the worker begins
rendering using the desired number of threads (defaults to number of logical cores). After finishing
its blocks for a frame the worker sends its results back to the master which is watching for readable events
on all the workers. Once the master has collected results from all the workers
for a frame it saves out the image and marks it completed. After the workers have finished their blocks
for the last frame being rendered they exit, once the master has saved out the last frame it also exits.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;The full code for the distributed rendering is in tray_rust’s &lt;a href=&quot;https://github.com/Twinklebear/tray_rust/tree/master/src/exec/distrib&quot;&gt;exec::distrib&lt;/a&gt;
module if you’re interested in some more details.&lt;/p&gt;

&lt;h1 id=&quot;scalability&quot;&gt;Scalability&lt;/h1&gt;

&lt;p&gt;Now that we’ve implemented a distributed computation we’d like to know how well it scales as we add
more workers (strong scaling). For these tests I used two scenes: one is pretty simple with some minor
work imbalance which should reveal issues more related to communication overhead while the other scene
is very imbalanced and will test scaling issues in the presence of uneven work distribution.&lt;/p&gt;

&lt;p&gt;The simpler scene is the classic Cornell box which we’ll render at 800x600 resolution with
1024 samples per pixel using path tracing. The load imbalanced scene is the
&lt;a href=&quot;http://graphics.stanford.edu/data/3Dscanrep/&quot;&gt;Stanford Buddha&lt;/a&gt; placed inside the Cornell box,
this results in a few workers having a
complex model to deal with while the majority of them are just intersecting the walls. The Buddha
box is rendered at 1280x720 with 1024 samples per pixel using path tracing. Since we’re using
path tracing it’s likely that paths traced which initially hit a wall will bounce around the scene
and intersect the Buddha but the pixels that see it directly will still have more work
vs. those that hit it indirectly.&lt;/p&gt;

&lt;div class=&quot;col-md-12 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/usuLnIj.png&quot; alt=&quot;Cornell Box&quot; /&gt;
&lt;i&gt;Cornell Box test scene&lt;/i&gt;

&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/hOZmzlB.png&quot; alt=&quot;Buddha Box&quot; /&gt;
&lt;i&gt;Buddha Box test scene&lt;/i&gt;
&lt;/div&gt;

&lt;p&gt;To run these scaling tests I used two clusters at my lab, one is a bit older which we’ll refer to
as &lt;em&gt;old&lt;/em&gt; while the newer machine we’ll call &lt;em&gt;new&lt;/em&gt;. The machine specifications are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;old:&lt;/em&gt; 64 nodes, each with two &lt;a href=&quot;http://ark.intel.com/products/37106/Intel-Xeon-Processor-X5550-8M-Cache-2_66-GHz-6_40-GTs-Intel-QPI&quot;&gt;Xeon X5550&lt;/a&gt; CPUs.
This is a legacy machine though so a few nodes have failed and won’t be repaired, combined with other users
running on the machine as well I was only able to get up to 44 nodes.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;new:&lt;/em&gt; 32 nodes, each with two &lt;a href=&quot;http://ark.intel.com/products/64584/Intel-Xeon-Processor-E5-2660-20M-Cache-2_20-GHz-8_00-GTs-Intel-QPI&quot;&gt;Xeon E5-2660&lt;/a&gt; CPUs.
Since some other users are running on
this machine (but not using many threads) I used just 30 threads/node since they had the remaining two.
This shouldn’t change the speedup numbers though since our
baseline time (1x) is a single node with 30 threads. On this machine I tested up to 28 nodes as a few were
down or otherwise occupied.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These plots show speedup over a single node which is set as our baseline of 1x compared to perfect
strong scaling. In the case of perfect strong scaling we’d expect that if 1 node is 1x then 20 nodes
should run at 20x the speed, however this is quite hard to achieve.&lt;/p&gt;

&lt;div class=&quot;col-md-12&quot;&gt;
&lt;div class=&quot;col-md-10 offset-md-1 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;/assets/img/distrib_rendering_scaling/old_scaling.svg&quot; /&gt;
&lt;i&gt;Old cluster strong scaling, 16 threads/node&lt;/i&gt;
&lt;/div&gt;
&lt;div class=&quot;col-md-10 offset-md-1 text-md-center&quot;&gt;
&lt;img class=&quot;img-fluid&quot; src=&quot;/assets/img/distrib_rendering_scaling/new_scaling.svg&quot; /&gt;
&lt;i&gt;New cluster strong scaling, 30 threads/node&lt;/i&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;On the &lt;em&gt;old&lt;/em&gt; cluster for the Cornell box we see a speedup of 37.57x when using 44 nodes, for
the Buddha box we see only 30.53x. On the &lt;em&gt;new&lt;/em&gt; cluster
for the Cornell box we get a speedup of 24.95x at 28 nodes while with the Buddha box we get
a speedup of just 18.91x. So why do we not scale as well as we’d hope, especially on the Buddha box?
I have two ideas on possible improvements to tray_rust’s scalability.&lt;/p&gt;

&lt;h2 id=&quot;scaling-issue-1-grouping-workers-results&quot;&gt;Scaling Issue 1: Grouping Worker’s Results&lt;/h2&gt;

&lt;p&gt;Currently we have a pretty large chunk of overhead when sending results back: for each 2x2 block of results
sent by a worker it includes an additional 16 byte header specifying the block’s location, adding
a 25% size overhead to the block. This is most clearly seen in the Cornell box tests since its workload
is relatively balanced. We can see that it stays closer to perfect scaling for longer than the
Buddha box and when it starts to break down some (about 22 nodes on &lt;em&gt;old&lt;/em&gt; and 16 on &lt;em&gt;new&lt;/em&gt;) it doesn’t drop
as fast. However it clearly is trailing off further from perfect scaling
as we get to higher node counts where we get less and less speedup for each additional node.&lt;/p&gt;

&lt;p&gt;I think this is coming from an increased amount of data sent to the master as we add nodes.
Recall that when using reconstruction filtering nodes write to pixels in blocks assigned to
other nodes so neighbors will send some overlapping data. The amount of overlapping data grows as
we add more nodes since more nodes will overlap each other’s regions. A possible solution is to
find the fewest number of bounding rectangles that contain the pixels the node has written to that will
minimize the amount of pixels and block headers we need to send.&lt;/p&gt;

&lt;p&gt;This is mostly a strong hunch at the moment but will be cleared up by doing some scaling tests
on renders without reconstruction filtering. Without reconstruction filtering there will be no overlap
between regions that nodes write to so we can measure scaling without this issue of overlapping data.&lt;/p&gt;

&lt;h2 id=&quot;scaling-issue-2-work-stealing&quot;&gt;Scaling Issue 2: Work Stealing&lt;/h2&gt;

&lt;p&gt;The Buddha box scene performs even worse than the Cornell box scene, it starts to drop off at lower node
counts than the Cornell box and continues to fall behind in terms of added speedup per node. While the culprit
in the Cornell box scaling results I’m a bit less sure on, I’m pretty confident that a lack of load balancing
among the workers is what hurts the Buddha box scene’s scaling the most.&lt;/p&gt;

&lt;p&gt;When looking at some of the individual worker render times
for a 25 node run on &lt;em&gt;new&lt;/em&gt; the fastest worker finished in 39.2s while the slowest
took 57.6s! In fact most nodes finished in about 39-42s while the few stuck with large portions of the Buddha
took 51-57s.
For about 22s we have workers finishing and exiting when they could actually be helping other workers still
rendering to finish faster.&lt;/p&gt;

&lt;p&gt;The clear fix here is to implement some form of distributed work stealing to allow workers to look around
for more blocks to render once they finish their assigned blocks (minus any stolen from them). I don’t
know anything about distributed work stealing and it sounds like a pretty complicated topic so I haven’t
thought much about actually implementing this. It would be really awesome to try out though and should help
quite a bit with scalability, especially on imbalanced scenes.&lt;/p&gt;

&lt;h2 id=&quot;scalability-cap&quot;&gt;Scalability Cap&lt;/h2&gt;

&lt;p&gt;As a result of the block based work decomposition we chose in the beginning we’re limited on how
many threads we can take advantage of. For the 400x304 Cornell box example we have 1900 8x8 blocks to
render, if we have more than 1900 cores available we can’t take advantage of them as we simply have
no work to assign them. An easy fix here would be to detect this case and have the master
or workers subdivide the blocks to 4x4 or 2x2 to decompose the problem further so we can
assign these extra threads some work.&lt;/p&gt;

&lt;h2 id=&quot;fault-tolerance&quot;&gt;Fault Tolerance&lt;/h2&gt;

&lt;p&gt;Another limitation of the current distributed rendering is that there is no fault tolerance. If a worker
goes down in the current system the master will detect the error and terminate, which will propagate the
termination to the remaining workers. For long runs especially at high node counts worker failures
are not that rare and a much better approach here would be to redistribute the failed worker’s blocks.
I’m unsure if this is something I’ll implement, in the presence of work stealing it would become even more
complex. For example we wouldn’t want to re-assign blocks that were stolen from the worker before it crashed,
but determining which blocks were stolen might be tough.&lt;/p&gt;

&lt;h1 id=&quot;try-tray_rust-yourself&quot;&gt;Try tray_rust Yourself!&lt;/h1&gt;

&lt;p&gt;Recently I’ve put together a simple &lt;a href=&quot;https://github.com/Twinklebear/tray_rust_blender&quot;&gt;Blender plugin&lt;/a&gt;
for tray_rust which will let you export static and keyframe animated scenes from Blender to a tray_rust
scene. There are still quite a few limitations which you can see discussed on the Github page but most
of these aren’t as difficult to work around compared to positioning objects by hand in a text file.
You’ll still need to specify materials by hand in the scene file, this is documented in the
&lt;a href=&quot;http://www.willusher.io/tray_rust/tray_rust/material/index.html&quot;&gt;materials&lt;/a&gt; module but is still pretty
user unfriendly.
Definitely try it out, if you put together a scene I’d be really excited to see it so tweet any
renders to me on Twitter &lt;a href=&quot;https://twitter.com/_wusher&quot;&gt;@_wusher&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Here’s a neat one I put together using Blender’s physics simulation by baking the simulation
to keyframes before exporting. If the video doesn’t play
properly you can download it &lt;a href=&quot;http://sci.utah.edu/~will/rt/rust_logos.mp4&quot;&gt;here&lt;/a&gt;. The Rust logo was
modeled by &lt;a href=&quot;http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo&quot;&gt;Nylithius&lt;/a&gt;, many
of the models in the scene make use of measured material data from the
&lt;a href=&quot;http://www.merl.com/brdf/&quot;&gt;MERL BRDF database&lt;/a&gt;. The animation was rendered with 28 nodes on &lt;em&gt;new&lt;/em&gt;
using the distributed renderer with 1024 samples per pixel and took 03:44:02 to render.&lt;/p&gt;

&lt;video class=&quot;img-fluid&quot; src=&quot;http://sci.utah.edu/~will/rt/rust_logos.mp4&quot; type=&quot;video/mp4&quot; controls=&quot;&quot; style=&quot;padding-top:16px;padding-bottom:16px;&quot; preload=&quot;metadata&quot; poster=&quot;http://i.imgur.com/KFRqLAo.png&quot;&gt;
Sorry your browser doesn't support HTML5 video, but don't worry you can download the video
&lt;a href=&quot;http://sci.utah.edu/~will/rt/rust_logos.mp4&quot;&gt;here&lt;/a&gt; and watch it locally.
&lt;/video&gt;

&lt;p&gt;If you’d like to try using the distributed renderer you can do so with any machines on a network, so
some desktops or laptops will work, or you can grab some compute instances from Google Compute Engine
or AWS EC2.
See the &lt;a href=&quot;http://www.willusher.io/tray_rust/tray_rust/exec/distrib/index.html&quot;&gt;exec::distrib&lt;/a&gt;
module documentation for more information on how to run the distributed render,
or run tray_rust with &lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; for a shorter summary of options.&lt;/p&gt;

&lt;script src=&quot;/assets/markdeep_modified_min.js&quot;&gt;&lt;/script&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="Rust" /><category term="ray tracing" /><category term="graphics" /><category term="animation" /><category term="distributed rendering" /><summary type="html">In this post we’ll take a look at adding distributed rendering to tray_rust which will let us take advantage of multiple machines when rendering an image, like a compute cluster. To do this we’ll look at options for how to distribute the rendering job across multiple nodes and what sort of communication is needed synchronize their work. We’ll also look into how we can use mio to write an efficient master process that can manage multiple workers effectively. After implementing a simple technique to distribute the job we’ll discuss the scalability of this approach and possible paths forward to improve it. I’ve also recently written a plugin for Blender so you can easily create your own scenes and will mention a bit on how to run the ray tracer on Google Compute Engine (or AWS EC2) if you want to try out the distributed rendering yourself.</summary></entry><entry><title type="html">Rendering an Animation in Rust</title><link href="http://localhost:4000/2015/12/16/rendering-an-animation-in-rust" rel="alternate" type="text/html" title="Rendering an Animation in Rust" /><published>2015-12-16T00:00:00-07:00</published><updated>2015-12-16T00:00:00-07:00</updated><id>http://localhost:4000/2015/12/16/rendering-an-animation-in-rust</id><content type="html" xml:base="http://localhost:4000/2015/12/16/rendering-an-animation-in-rust">&lt;p&gt;In this post we’ll look at adding a pretty awesome new feature to &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt;,
something I’ve never implemented before: animation! We’ll take a look at a simple way for sampling time in our scene, how
we can associate time points with transformations of objects to make them move and how to compute smooth animation
paths with B-Splines. Then we’ll wrap up with rendering a really cool animation by using 60 different
machines spread across two clusters at my lab.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;rendering-time&quot;&gt;Rendering Time&lt;/h1&gt;

&lt;p&gt;Now that we want objects in our scene to move over time, we need some way to account for time when rendering.
A straightforward approach is to consider time as just another variable we’re integrating over in
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rendering_equation&quot;&gt;rendering equation&lt;/a&gt; (Wikipedia is one step ahead of us and
already has time in the equation). When we shoot a ray to sample
a pixel in the scene we’re also sampling a specific point in time, so each ray will have a time value
associated with it. This time value will allow us to find out where objects are when this ray “see’s” the scene
so to speak. Since we blend our samples together to form the final image this will also let us compute nice motion
blur, though it will require more samples as it introduces further variance into the image which
will appear as more noise.&lt;/p&gt;

&lt;p&gt;To pick the time values to assign to rays we chop up the time for the scene, say four seconds, into frames. We can
pick a common film framerate of 24 frames per second, or whatever we want really. At 24 frames per second we’ll need 96 frames
for a 4 second scene, where each frame captures 1/24 of a second of the scene. We can have a simple loop
over the frames to be rendered that will update the camera’s shutter open/close times to span the current frame.
When firing a new ray into the scene we pick its time value by scaling a random sample in [0, 1] into the current shutter time range.
This way we’ll advance the scene forward in time by advancing the camera’s shutter time (so we see motion across frames) and
will sample a range of time values for a frame while the shutter is open (so we see motion blur in a frame).&lt;/p&gt;

&lt;p&gt;An interesting technique to explore is how changing the length of time the shutter is open during a frame effects the captured image.
In movies the shutter is typically open for 1/48 of a second for a 1/24 second long frame. It’s open for half
the frame since the shutter that blocks the light is 180 degrees and rotates 360 degrees every 1/24 a second. In
&lt;a href=&quot;http://cinemashock.org/2012/07/30/45-degree-shutter-in-saving-private-ryan/&quot;&gt;Saving Private Ryan&lt;/a&gt; they
used a 45 degree shutter so the shutter is open for just 1/192 of a second each frame. This results in less
motion blur appearing on moving objects since the range of time we sample is much shorter, so the object moves
a shorter distance while the shutter is open. This is not currently supported in tray_rust but is on my list and should be really
cool to implement. For example by controlling the shutter speed we can reduce the amount of motion blur we see and create a stop
motion appearance in our animations.&lt;/p&gt;

&lt;figure class=&quot;img-fluid&quot;&gt;
	&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/Q98K76K.png&quot; alt=&quot;Shutter Angle, wikipedia&quot; /&gt;
	&lt;figcaption&gt;&lt;i&gt;Shutter Angle, (&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotary_disc_shutter&quot;&gt;Wikipedia&lt;/a&gt;)&lt;/i&gt;
	&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;transforming-objects-over-time&quot;&gt;Transforming Objects Over Time&lt;/h1&gt;

&lt;p&gt;To get rigid body animation we can associate an object’s transform with a specific point in time and interpolate
between one or more neighboring transforms (in time) to animate it during the scene.
This falls out of our rays sampling a specific point in time. When we want to compute where the object is at
the time this ray traverses the scene we can interpolate the transformations near its time sample to compute its
transform at the ray’s time.
By sampling over the shutter time and across multiple frames we can move an object in the scene and
compute motion blur as it moves. In order to properly interpolate the transforms they are decomposed
into separate translation, scaling and rotation components, interpolated separately and then combined to the
final transformation.&lt;/p&gt;

&lt;p&gt;The camera needs no special treatment here since it’s also positioned by a transformation matrix and we can
animate it in the same way that we do other objects in the scene. Instead of finding where an object is when the
ray is intersecting it we transform the ray by where the camera is when the ray is leaving it.&lt;/p&gt;

&lt;p&gt;With objects moving around in the scene we also need our BVH to account for this, the bounding boxes it stores
for objects must actually bound them over the time range that we’re rendering for the current frame. Without this
objects can actually disappear or get clipped because we won’t traverse the acceleration structure to
intersect them since we think we miss their bounding box! My current approach is to sample the
transformation of the object over the current shutter time and find the union of these bounding boxes. This is
not the most accurate solution (&lt;a href=&quot;https://github.com/mmp/pbrt-v3&quot;&gt;pbrt-v3&lt;/a&gt; introduces a better one) but it’s
simple to implement. To try and avoid the BVH becoming low quality due to the motion of objects causing all their
bounding boxes to overlap (thus requiring us to traverse more of the tree) I also re-build the BVH each frame to only contain
the motion bounds of objects within the current shutter time range we’re actually rendering (e.g. 1/24 of a second at 24 FPS).&lt;/p&gt;

&lt;p&gt;One thing worth mentioning is that currently tray_rust doesn’t support skeletal animation, just rigid body animation.
While it may be possible with the current system it would be pretty slow and inefficient. There currently is no support
for bone transforms that would be weighted and referenced by many triangles and my current BVH construction is too slow
to efficiently handle animating complicated meshes. Animated meshes would also cause problems for the instancing system,
as different instances of the same mesh could go through different animations at the same time.&lt;/p&gt;

&lt;h1 id=&quot;smooth-animations-with-b-splines&quot;&gt;Smooth Animations with B-Splines&lt;/h1&gt;

&lt;p&gt;We would like the motion our objects go through to be smooth, that is the paths they follow should
not have discontinuities (unless we actually want them) and they should smoothly accelerate when starting
and stopping the motion. This leaves us with a small problem, since linear interpolation between the nearest
two transforms at some time is likely to give discontinuities in paths and not have smooth acceleration. Additionally,
since linear interpolation is equivalent to drawing lines between the transforms we specify, it would be tedious
to set up an animation that followed a smooth curve as it would require many tiny linear paths to approximate the
smooth path we actually want.&lt;/p&gt;

&lt;p&gt;To compute smooth animation paths from the list of control transforms for the object we can use
&lt;a href=&quot;https://en.wikipedia.org/wiki/B-spline&quot;&gt;B-Splines&lt;/a&gt;, which will smoothly interpolate the transforms,
though may not exactly pass through them. There wasn’t an existing B-Spline interpolation library in
Rust so I created a &lt;a href=&quot;https://github.com/Twinklebear/bspline&quot;&gt;generic one&lt;/a&gt;. In the implementation of this
library we get the opportunity to explore another powerful aspect of Rust’s trait system.
To compute a point on the curve we perform a sequence of linear interpolations that build on each other,
thus a B-Spline curve can be used to interpolate any “control point” type that can be linearly
interpolated, e.g. 2/3D positions, RGB colors or even transformations (our goal). The library can
define a trait for types that can be linearly interpolated:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interpolate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Linearly interpolate between `self` and `other` using `t`, for example this could return:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// self * (1.0 - t) + other * t&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;interpolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For convenience we can even provide a default implementation for any types which can be multiplied by a float,
added to each other and copied to return the result. Then if someone uses our Interpolate trait they
won’t necessarily need to write this simple implementation themselves. Instead they would only need to provide it
in the case that their type needed some special handling (e.g. spherical linear interpolation for quaternions).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// Mul&amp;lt;f32, Output = T&amp;gt; - This type can be multiplied by itself and returns a result of its type.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Add&amp;lt;Output = T&amp;gt; - This type can be added together and return a result of its type.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Copy - This type is bitwise copyable&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interpolate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;interpolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The B-Spline curve provided by the library can operate on any type that implements Interpolate and Copy. Copy
is required again because Interpolate does not imply the type has implemented Copy and we need it to save
intermediate results and return the final interpolated value. As a bonus since the B-Spline struct is
templated on the type being interpolated there’s no virtual function overhead when calling &lt;code class=&quot;highlighter-rouge&quot;&gt;interpolate&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BSpline&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interpolate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Degree of the polynomial that we use to make the curve segments&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Control points for the curve&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;control_points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// The knot vector&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;knots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A comparison of linear interpolation with cubic B-Spline interpolation of the same set of control points is shown below,
produced by changing the degree and knots of the &lt;a href=&quot;https://github.com/Twinklebear/bspline/blob/master/examples/plot2d.rs&quot;&gt;plot2d example&lt;/a&gt;
included with the library.&lt;/p&gt;

&lt;div class=&quot;row&quot;&gt;
&lt;div class=&quot;col-xs-12 col-md-6&quot;&gt;
&lt;figure class=&quot;img-fluid&quot;&gt;
	&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/LL5vG3z.png&quot; alt=&quot;Linear Interpolation&quot; /&gt;
	&lt;figcaption&gt;&lt;i&gt;Linear Interpolation&lt;/i&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;col-xs-12 col-md-6&quot;&gt;
&lt;figure class=&quot;img-fluid&quot;&gt;
	&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/kk5rtXK.png&quot; alt=&quot;Cubic B-Spline Interpolation&quot; /&gt;
	&lt;figcaption&gt;&lt;i&gt;Cubic B-Spline Interpolation&lt;/i&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Although the B-Spline curve provides us with a much smoother and more desirable animation path it also doesn’t pass
through the control points that manipulate the curve. This makes it somewhat challenging to model animations since
I don’t have a GUI editor for tray_rust and it’s tough to visualize how the curve looks when typing in control
transforms and knots.&lt;/p&gt;

&lt;h1 id=&quot;creating-and-rendering-a-cool-scene&quot;&gt;Creating and Rendering a Cool Scene!&lt;/h1&gt;

&lt;p&gt;With the pieces together all that’s left to do is make a really awesome animation! This is actually
a bit challenging at the moment since I don’t have any sort of graphical editor (and no plugin for Blender).
To create a scene you type in the control transforms, knot vectors and so on into a potentially huge
JSON scene file (for example &lt;a href=&quot;https://github.com/Twinklebear/tray_rust/blob/master/scenes/tr15.json&quot;&gt;here’s this animation’s scene&lt;/a&gt;).
Then to check if you’ve got about what you
had in mind render some lower resolution frames to see the motion of objects and the camera.
Putting together even just this short 25 second animation took quite a while, since I’d spend a
lot of time tweaking the object and camera paths, materials and so on. I also found and fixed a few bugs
while working on the animation which took some time as well, but bug fixing is time well spent. The animation is
1920x1080 and was rendered at 2048 samples per pixel. To get 25 seconds of animation at 24 frames
per second we need to render 600 individual frames. Each frame is saved out as a separate png, to produce
the animation I used ffmpeg to stitch them together into a video.&lt;/p&gt;

&lt;p&gt;Here’s the resulting video. If you’d prefer to watch on YouTube I’ve &lt;a href=&quot;https://youtu.be/sweEpfRyDlE&quot;&gt;uploaded it there&lt;/a&gt; as well but the quality is
not as good due to compression. If your browser doesn’t play the video properly you can
&lt;a href=&quot;http://sci.utah.edu/~will/rt/rtc_2015_med_quality_420p.mp4&quot;&gt;download it&lt;/a&gt; and watch it locally.&lt;/p&gt;

&lt;video class=&quot;img-fluid&quot; src=&quot;http://sci.utah.edu/~will/rt/rtc_2015_med_quality_420p.mp4&quot; type=&quot;video/mp4&quot; controls=&quot;&quot; style=&quot;padding-top:16px;padding-bottom:16px;&quot; preload=&quot;metadata&quot; poster=&quot;http://i.imgur.com/ftJyrnA.jpg&quot;&gt;
Sorry your browser doesn't support HTML5 video, but don't worry you can download the video
&lt;a href=&quot;http://sci.utah.edu/~will/rt/rtc_2015_med_quality_420p.mp4&quot;&gt;here&lt;/a&gt; and watch it locally.
&lt;/video&gt;

&lt;p&gt;The animation contains quite a few different models:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The Stanford Bunny, Buddha, Dragon and Lucy are from the
&lt;a href=&quot;http://graphics.stanford.edu/data/3Dscanrep/&quot;&gt;Stanford 3D Scanning Repository&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The Utah Teapot (I used &lt;a href=&quot;http://graphics.cs.williams.edu/data/meshes.xml&quot;&gt;Morgan McGuire’s version&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Low-poly pine trees by &lt;a href=&quot;http://kenney.nl/&quot;&gt;Kenney&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The Ajax bust is from &lt;a href=&quot;http://forum.jotero.com/viewtopic.php?t=3&quot;&gt;jotero&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;A Rust logo model by &lt;a href=&quot;http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo&quot;&gt;Nylithius&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The Cow model is from Viewpoint Animation, I downloaded the model from the Suggestive Contours paper
&lt;a href=&quot;http://gfx.cs.princeton.edu/proj/sugcon/models/&quot;&gt;example page&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I also make use of a mix of analytic and measured material models, the measured materials come
from the &lt;a href=&quot;http://www.merl.com/brdf/&quot;&gt;MERL BRDF Database&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;compute-time&quot;&gt;Compute Time&lt;/h2&gt;

&lt;p&gt;When I rendered this animation tray_rust didn’t support true distributed rendering (multiple machines
cooperating on a single frame), however a simple and effective
approach is to assign a subset of the frames to different machines so they split the work.
Since each frame is saved out as a png each node’s job is completely independent of the others so we can
just launch the renderer on a bunch of machines and not worry much about fault handling or
communication overhead (since there’s none). This actually achieves pretty effective use of a cluster,
as long as you have more frames than nodes.&lt;/p&gt;

&lt;p&gt;To render the scene I used two clusters at my lab which don’t get much use over the weekend. I used 40 nodes
with two Xeon X5550’s per node on one cluster and 20 nodes with two Xeon E5-2660’s per node on the other,
for a total of 1280 logical cores (640 physical). I tried to balance the performance of the nodes when
assigning frames to aim for an even-ish work distribution. The scene took a wall time of about 53 hours to render
due to some of my jobs starting a bit later than other ones. The total wall time (sum of all nodes) is 2772 hours
(16.5 weeks!), on average rendering took about 46.2 hours per node (wall time). The total CPU time
(sum of all nodes) was 56853 hours (6.486 years!). Without using these clusters I don’t think I would have
been able to render in such high quality, just due to how long it would have taken. I definitely need to
spend some more time improving the performance of tray_rust.&lt;/p&gt;

&lt;h1 id=&quot;next-time&quot;&gt;Next Time&lt;/h1&gt;

&lt;p&gt;Although tray_rust didn’t support distributed rendering when I rendered this scene I’ve just recently
implemented it, which is what we’ll take a look at in the next post. As a
quick teaser we’ll see how to divide work for a single frame between multiple nodes, properly handle nodes
reporting multiple frames at different times and how to read results from multiple nodes on one thread using
&lt;a href=&quot;https://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; for asynchronous I/O.&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="Rust" /><category term="ray tracing" /><category term="graphics" /><category term="animation" /><summary type="html">In this post we’ll look at adding a pretty awesome new feature to tray_rust, something I’ve never implemented before: animation! We’ll take a look at a simple way for sampling time in our scene, how we can associate time points with transformations of objects to make them move and how to compute smooth animation paths with B-Splines. Then we’ll wrap up with rendering a really cool animation by using 60 different machines spread across two clusters at my lab.</summary></entry><entry><title type="html">Porting a Ray Tracer to Rust, part 3</title><link href="http://localhost:4000/2015/05/15/porting-a-ray-tracer-to-rust-part-3" rel="alternate" type="text/html" title="Porting a Ray Tracer to Rust, part 3" /><published>2015-05-15T00:00:00-06:00</published><updated>2015-05-15T00:00:00-06:00</updated><id>http://localhost:4000/2015/05/15/porting-a-ray-tracer-to-rust-part-3</id><content type="html" xml:base="http://localhost:4000/2015/05/15/porting-a-ray-tracer-to-rust-part-3">&lt;p&gt;It’s been a little while since my last post on tray_rust as I’ve been a busy with classes, but I’ve
had a bit of free time to implement some extremely cool features. In this post we’ll look at porting over
the path tracing code and adding a bounding volume hierarchy, along with adding support for triangle meshes and measured material data from the
&lt;a href=&quot;http://www.merl.com/brdf/&quot;&gt;MERL BRDF Database&lt;/a&gt; introduced by Matusik et al. in 2003 in
&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=882343&quot;&gt;A Data-Driven Reflectance Model&lt;/a&gt;. In the process of implementing the BVH we’ll get a taste
of Rust’s generic programming facilities and use them to write a flexible BVH capable of storing any type that can
report its bounds. In the spirit of fogleman’s gorgeous &lt;a href=&quot;https://github.com/fogleman/pt&quot;&gt;Go Gopher in Go&lt;/a&gt; we’ll wrap up
by rendering the Rust logo in Rust using a model made by
&lt;a href=&quot;http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo&quot;&gt;Nylithius on BlenderArtists&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve been following Rust’s development a bit you have probably noticed that the timing of this post is not a
coincidence, since Rust 1.0.0 is being released &lt;a href=&quot;http://blog.rust-lang.org/2015/05/15/Rust-1.0.html&quot;&gt;today&lt;/a&gt;!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;path-tracing&quot;&gt;Path Tracing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Path_tracing&quot;&gt;Path tracing&lt;/a&gt;, introduced by Kajiya in 1986 in &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=15902&quot;&gt;The Rendering Equation&lt;/a&gt;,
is a standard and surprisingly simple method for computing photo-realistic images in computer graphics.
This simplicity and quality does come at a cost and path traced images typically require thousands of samples
per pixel to compute a mostly noise-free image (some more on this shortly). While I won’t try and fully explain path tracing since I won’t be able to cover
it as well as other resources around, a short overview of the method is helpful. I’ll also include some links to other resources where you
can read up more on the topic and get a more in depth explanation.&lt;/p&gt;

&lt;p&gt;The concept underlying path tracing is pretty straightforward: if we think about a point on a surface in some scene, the light we see at this point is the result
of all light incident on the point from other surfaces and lights modulated by the surface’s reflectance properties at the point,
along with any light emitted by the surface itself at the point. Considering a point on a plane this gives us an integral over
a hemisphere centered at the point. Note that this doesn’t constrain us
to planar objects, eg. a point on some edge would just integrate over a larger hemi-spherical region. This idea gives us the
&lt;a href=&quot;http://en.wikipedia.org/wiki/Rendering_equation&quot;&gt;rendering equation&lt;/a&gt; and solving this equation will compute the illumination at every point in the scene.&lt;/p&gt;

&lt;p&gt;The equation on Wikipedia is a bit more than we’ll be needing here as we’ll only be rendering static scenes and won’t consider wavelength dependent effects,
allowing us to drop \(t\) and \(\lambda\). This lets us write down an easier to parse version of the equation:&lt;/p&gt;

&lt;p&gt;\[
L_o(x, w_o) = L_e(x, w_o) + \int_{\Omega} f(x, w_i, w_o) L_i(x, w_i) w_i \cdot n \; \text{d}w_i
\]&lt;/p&gt;

&lt;p&gt;Here \(L_o(x, w_o)\) is the computed outgoing radiance along direction \(w_o\) leaving \(x\), \(L_e\) is the equivalent for light emitted at the point
and \(L_i(x, w_i)\) is the incident light coming from direction \(w_i\) arriving at the point. \(f(x, w_i, w_o)\) is the surface’s
&lt;a href=&quot;http://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function&quot;&gt;Bidirectional reflectance distribution function (BRDF)&lt;/a&gt; which describes
how light arriving at the point along direction \(w_i\) is reflected back along \(w_o\). The BRDF is used to describe opaque surfaces and in general
the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bidirectional_scattering_distribution_function&quot;&gt;Bidirectional scattering distribution function (BSDF)&lt;/a&gt; applies, eg. to
transparent objects or subsurface scattering effects and so on. The final \(w_i \cdot n\) term is the geometry term and weakens light that arrives at
glancing angles. We then integrate this expression over the hemisphere \(\Omega\) to account for all light incident on the point.
This is of course a very shortened look at the rendering equation, for an excellent explanation on this topic (and many more)
I highly recommend reading &lt;a href=&quot;http://pbrt.org/&quot;&gt;Physically Based Rendering&lt;/a&gt;. If you’d like more detail but don’t want to buy a whole book on rendering
&lt;a href=&quot;http://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/realistic_raytracing.html&quot;&gt;Realistic Raytracing by Zack Waters&lt;/a&gt; and
&lt;a href=&quot;http://www.thepolygoners.com/tutorials/GIIntro/GIIntro.htm&quot;&gt;Global Illumination in a Nutshell&lt;/a&gt; linked in fogleman’s readme look to be good as well.&lt;/p&gt;

&lt;p&gt;While it’s possible to solve the rendering equation analytically for some very simple scenes our situation is pretty hopeless in most cases.
To compute the integral for general scenes we turn to random sampling and employ &lt;a href=&quot;http://en.wikipedia.org/wiki/Monte_Carlo_method&quot;&gt;Monte Carlo integration&lt;/a&gt;. Solving
the rendering equation with path tracing amounts to tracing millions of rays, taking thousands of samples per pixel to sufficiently sample the integral.
Starting with an eye ray we find the first surface it hits, sample a light source for direct illumination (if there’s many we just pick one at random)
and compute \(f(x, w_l, w_o)\) to modulate this incident light coming along \(w_l\). Next we pick a random direction from a cosine weighted distribution
on the hemisphere to shoot another ray
to sample indirect lighting and again compute \(f(x, w_i, w_o)\) for this direction to modulate the incident indirect light then find what
this secondary ray hits and repeat. This process can continue infinitely so we’ll terminate the ray
at some configurable number of bounces, since the indirect light reaching our first hit is attenuated at each bounce after a certain depth there’s very little
illumination coming back along the path and it’s ok to terminate the ray.
The &lt;a href=&quot;http://en.wikipedia.org/wiki/Path_tracing#Algorithm&quot;&gt;pseudo-code&lt;/a&gt; on Wikipedia gives a decent overview of the algorithm.&lt;/p&gt;

&lt;p&gt;Although we’re able to render any scene with path tracing our usage of Monte Carlo integration requires that we must take huge numbers of samples
to accurately sample the integral. The effect of sampling rate on image quality is shown below, with very few samples per pixel the result is quite poor and
very noisy but as we take more and more it converges to a high quality image. As you would expect, taking more samples per pixel comes with an
increased rendering cost. On a machine with an &lt;a href=&quot;http://ark.intel.com/products/80807/Intel-Core-i7-4790K-Processor-8M-Cache-up-to-4_40-GHz&quot;&gt;i7-4790k&lt;/a&gt;
using 8 threads the image with 2 samples per pixel takes a mere 90ms to render while with 2048 samples it takes 94.203s to render the 200x200 pixel image.
A massive increase in render time of three orders of magnitude!&lt;/p&gt;

&lt;div class=&quot;row col-12 text-center justify-content-center&quot;&gt;
&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/sPGEQhO.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/sPGEQhO.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;2 samples&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/rF0SWIY.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/rF0SWIY.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;8 samples&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/Tbbuzhs.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/Tbbuzhs.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;32 samples&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/eJJ290s.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/eJJ290s.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;128 samples&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/mUZOd0L.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/mUZOd0L.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;512 samples&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;col-4&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/rYA2keF.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/rYA2keF.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;2048 samples&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;bounding-volume-hierarchy&quot;&gt;Bounding Volume Hierarchy&lt;/h2&gt;
&lt;p&gt;If we wanted to render a scene with millions (or billions!) of triangles the process of finding the first intersection
along a ray can become incredibly expensive, eg. using a naive loop over the triangles would probably have us waiting days or even weeks for our render.
To avoid this issue we use some form of spatial partitioning data structure that will let us ignore objects that the ray has no chance of hitting.
There are many possibilities for choosing a spatial data structure but the two most popular in ray tracing are
&lt;a href=&quot;http://en.wikipedia.org/wiki/Bounding_volume_hierarchy&quot;&gt;Bounding Volume Hierarchies&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/K-d_tree&quot;&gt;K-d trees&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve chosen to implement a BVH since building a reasonably high quality one is not too costly a process and traversal is pretty straightforward. At a high
level we construct a tree of bounding axis aligned boxes that contain geometry in the scene and partition them into groups such that the estimated
cost of testing the geometry in each child is as equal as possible. This method is known as the surface area heuristic as we use the object’s
surface area (or that of its bounding box) to estimate the cost of entering a node in the BVH. Traversal is then done by testing the
bounding boxes of each child node of an internal node, if a child is intersected then we traverse it recursively. When enter a leaf node storing
some geometry we test our ray for intersection against the objects inside.
Typically actual recursive calls are avoided and we manage the stack of nodes to be traversed ourselves.
Again I’ll defer the detailed explanation to &lt;a href=&quot;http://pbrt.org/&quot;&gt;PBRT&lt;/a&gt; and instead we’ll focus on some cool Rust features in this section
related to the implementation.&lt;/p&gt;

&lt;p&gt;We’d like our BVH to be generic over the type it stores and only require the information needed to construct the BVH be provided by the type, ie. that
the types being stored can report their bounds as an axis aligned box. As I mentioned in the
&lt;a href=&quot;http://www.willusher.io/2014/12/30/porting-a-ray-tracer-to-rust-part-1/#a-poor-design-choice&quot;&gt;first post of this series&lt;/a&gt; by doing this we’ll be able to use
the same type to store our instances of geometry in the world and triangles in a mesh and re-use the code. After some helpful discussion in the comments of
that post I’ve settled on a flexible and powerful implementation that takes advantage of Rust’s trait system. For some really
great discussion and background on traits in Rust take a look at &lt;a href=&quot;http://blog.rust-lang.org/2015/05/11/traits.html&quot;&gt;Aaron Turon’s Abstraction without overhead&lt;/a&gt; post.&lt;/p&gt;

&lt;p&gt;To provide a generic BVH that only requires types can report their world space bounds we’ll need two things. First we’ll need a trait to
implement on these objects that provides a function to get their bounds and we’ll need a way to pass a function to be called during the BVH traversal so
the caller can run eg. intersection tests. Additionally we’d like to return whatever this function returns from our traversal
(eg. this is information about the nearest hit triangle) and we’d like it to be possible for this function to be inlined as it will be
called a lot in our rendering loop. Using Rust’s traits we can meet all these demands handily.&lt;/p&gt;

&lt;p&gt;We’ll start by putting together a &lt;code class=&quot;highlighter-rouge&quot;&gt;Boundable&lt;/code&gt; trait for types that can report their bounds in space:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// Trait implemented by scene objects that can report an AABB describing their bounds&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boundable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Get an AABB reporting the object's bounds in space&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can put a constraint on the types that our BVH will accept:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BVH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boundable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boundable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BVH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally we can put together our intersection function for the BVH. This function will take a mutably borrowed ray and traverse it through the BVH,
calling the user’s function on objects within leaf nodes that the ray enters, the user’s function will then return an Option type indicating if an
intersection occured for example. After traversal has completed we’ll return an Option type to indicate if an intersection happened or not.
Additionally the caller’s function may need to modify the ray’s max t value (how long it is) as we find intersections with geometry during traversal.
We can require an appropriate user function by taking a generic type and constraining it to implement the &lt;a href=&quot;http://doc.rust-lang.org/std/ops/trait.Fn.html&quot;&gt;Fn&lt;/a&gt;
trait with the parameters and return values we expect. As an extra bonus, since we’ve made our intersect function generic on
the caller’s function and we take it by value the compiler can even inline calls to the Fn passed, similar to C++11 lambdas.&lt;/p&gt;

&lt;p&gt;The signature of our BVH intersect function then comes out like below. Note that the lifetime annotations are required as we
may be returning a reference to objects in the BVH in R and the compiler needs to know these references will be valid after
the call. This actually turned out to be a tough error to work through and the Rust IRC channel was very helpful.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now to traverse geometry in the BVH and intersect the instances or triangles within is as simple as passing a closure! For example,
here’s the intersect call of a &lt;code class=&quot;highlighter-rouge&quot;&gt;BVH&amp;lt;Instance&amp;gt;&lt;/code&gt; in scene.rs. Here our Fn takes a &amp;amp;mut Ray and &amp;amp;Instance and returns an Option&lt;Intersection&gt;
which represents the closest intersection with an instance found. The BVH will then traverse the hierarchy and call our function
on the geometry in each leaf node that our ray enters.&lt;/Intersection&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intersection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.bvh&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;lifetime-errors-can-be-challenging-to-decipher&quot;&gt;Lifetime Errors can be Challenging to Decipher&lt;/h3&gt;
&lt;p&gt;The hardest problems I encountered when writing the traversal were lifetime errors encountered in the course of trying
to return a reference to an object in the BVH from the closure, eg. in the Intersection or DifferentialGeometry structures we return
a reference to the hit Instance or Geometry respectively. Since the
error itself is given at the call to intersect it wasn’t clear what I’d need to do to help the compiler sort out the
lifetimes. A short self-contained example of the error can be found on &lt;a href=&quot;http://is.gd/uHBGlA&quot;&gt;Rust playpen&lt;/a&gt; if you’d like
to see the compiler error yourself (this may change as the compiler on playpen is updated). In the end
to make sense of the error I asked folks on the Rust IRC, who have always been
extremely helpful. They pointed out that I need to tie the lifetime of the &amp;amp;T passed to the caller’s Fn
with the lifetime of the BVH itself, thus indicating to the compiler that the reference will be valid as
long as the BVH is alive. This is done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;'a&lt;/code&gt; lifetime annotations in the intersect function signature.&lt;/p&gt;

&lt;p&gt;Without the help of people in IRC this probably would have taken much longer to figure out (if I could have figured it
out at all). Since Rust is a very young language the documentation and compiler are still being worked on and I think
more advanced lifetime handling and error reporting are areas that both could be improved. The concepts of lifetime
and ownership are key features in Rust but can be difficult to reason about and errors related to them can sometimes be
hard to interpret.&lt;/p&gt;

&lt;h2 id=&quot;triangle-meshes&quot;&gt;Triangle Meshes&lt;/h2&gt;
&lt;p&gt;Because we’ve implemented our BVH to be generic on the type it stores it’s simple for us to also write a
triangle mesh that uses a BVH internally to accelerate intersection testing against its triangles. The triangles
share Arcs to Vecs containing the position, normal and texture coordinate information and the index of each of
their vertices within these Vecs. This is different than my C++ implementation where the Mesh would store
these vectors and the triangles would store a reference to the Mesh instead of shared_ptr’s to the vectors. However the C++
implementation will result in dangling references unless used very carefully, eg. if the mesh is moved, copied or such we’ll end up
with dangling pointers. When I first tried to implement the Mesh I tried my C++ approach and the Rust compiler correctly
gave me some lifetime errors. Although there’s a bit of added size to each triangle
to store the Arc to each Vec this implementation is actually safe to use in general, unlike my C++ one (which I should correct).
I use a standard triangle intersection test from PBRT and after building
a BVH on the mesh’s triangles we end up with a very simple mesh type. The struct is just a BVH containing its triangles:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bvh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BVH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Testing the triangles of the mesh for intersection is the same as testing for intersections against Instances
of geometry, but instead we return an &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&amp;lt;DifferentialGeometry&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.bvh&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;publishing-crates-on-cargo&quot;&gt;Publishing Crates on Cargo&lt;/h3&gt;
&lt;p&gt;Now that we can quickly intersect rays against triangle meshes lets load up some models and render them! The
&lt;a href=&quot;http://en.wikipedia.org/wiki/Wavefront_.obj_file&quot;&gt;Wavefront OBJ&lt;/a&gt; format is relatively simple to load (at least if
you’re only doing triangles/triangle strips) and is widely supported in modeling software like Blender,
making it easy to find meshes and convert them if needed. While it’s possible to write an OBJ loader integrated
into the ray tracer I thought this seemed like a cool opportunity to learn about publishing my own Crates
(a Rust library) with &lt;a href=&quot;https://crates.io&quot;&gt;Cargo&lt;/a&gt; (Rust’s package manager), especially since managing dependencies with
Cargo is very smooth.&lt;/p&gt;

&lt;p&gt;To load OBJ files I’ve written &lt;a href=&quot;https://github.com/Twinklebear/tobj&quot;&gt;tobj&lt;/a&gt; (Tiny OBJ Loader) which takes inspiration from the
OBJ loader I use in my C++ projects, &lt;a href=&quot;https://github.com/syoyo/tinyobjloader&quot;&gt;tinyobjloader&lt;/a&gt;. To figure out how
to publish the crate online I followed &lt;a href=&quot;http://doc.crates.io/crates-io.html#publishing-crates&quot;&gt;the guide on publishing&lt;/a&gt;
and &lt;a href=&quot;https://crates.io/crates/tobj&quot;&gt;here it is&lt;/a&gt;! Adding this library as dependency to tray_rust can be done
by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;tobj = &quot;0.0.8&quot;&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;[dependencies]&lt;/code&gt; list in the project’s Cargo.toml and the crate will be downloaded and available for use
via &lt;code class=&quot;highlighter-rouge&quot;&gt;extern crate tobj;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For some extra fun I used the Travis-CI integration discussed in Huon’s “Travis on the Train” series
(&lt;a href=&quot;http://huonw.github.io/blog/2015/04/helping-travis-catch-the-rustc-train/&quot;&gt;part 1&lt;/a&gt;,
&lt;a href=&quot;http://huonw.github.io/blog/2015/05/travis-on-the-train-part-2/&quot;&gt;part 2&lt;/a&gt;) and can now take advantage of Travis-CI
to run tests and even build and upload &lt;a href=&quot;http://www.willusher.io/tobj/tobj/&quot;&gt;rustdoc&lt;/a&gt; for tobj, which is really
convenient. I’ve started using this for tray_rust as well.&lt;/p&gt;

&lt;h2 id=&quot;measured-material-data&quot;&gt;Measured Material Data&lt;/h2&gt;
&lt;p&gt;The final thing we need to make some really nice images are accurate material models, ie. ones that can closely approximate
the reflectance properties of various types of materials. There are
a wide range of analytic models that we can choose from that attempt to accurately model various
types of materials, &lt;a href=&quot;http://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function#Models&quot;&gt;Wikipedia&lt;/a&gt; has a decent list.
The current analytic models supported in tray_rust are &lt;a href=&quot;http://en.wikipedia.org/wiki/Lambertian_reflectance&quot;&gt;Lambertian&lt;/a&gt; (an ideal diffuse material),
&lt;a href=&quot;http://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model&quot;&gt;Oren-Nayar&lt;/a&gt; (more accurate model of rough surface reflectance)
and specular reflection (perfect mirror) and specular transparency (perfectly smooth glass).
An alternative to analytic models is to use measured data acquired by taking real world objects
and scanning them in some way to measure their BRDF. These measured models can be a bit harder to use as they don’t offer much
artist flexibility, but since I’m a terrible artist this isn’t a problem. One excellent source of measured
BRDF data is the &lt;a href=&quot;http://www.merl.com/brdf/&quot;&gt;MERL BRDF Database&lt;/a&gt; which has a wide variety of regularly sampled
isotropic material data, and is what we’ll be using here.&lt;/p&gt;

&lt;p&gt;The file format itself may seem a bit odd but is well explained in &lt;a href=&quot;http://pbrt.org/&quot;&gt;PBRT&lt;/a&gt; and after loading the data in access
is actually quite efficient. The file stores scaled RGB values for samples taken at various angles of incident and outgoing light
where components are scaled by (1500, 1500, 1500 / 1.66) for (R, G, B) in the file, so we must apply the inverse. Additionally the values
in the files are stored in little Endian double precision and in chunks, so all the red values come first, followed by green and then blue.
To load these binary files I made use of the &lt;a href=&quot;https://crates.io/crates/byteorder&quot;&gt;byteorder crate&lt;/a&gt;, which brings up another cool feature of Rust:
extension traits. It’s possible for libraries to add new traits to existing types, extending them with new methods. This is kept in check
by only having traits be in scope if you use them, eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;use my_lib::CoolTrait&lt;/code&gt; will make CoolTrait’s methods available on implementing types.
The byteorder crate extends methods on types that implement &lt;a href=&quot;http://doc.rust-lang.org/std/io/trait.Read.html&quot;&gt;Read&lt;/a&gt; with
&lt;a href=&quot;http://burntsushi.net/rustdoc/byteorder/trait.ReadBytesExt.html&quot;&gt;ReadBytesExt&lt;/a&gt;
(see the Implementors section at the bottom) to add on typed binary io methods. This makes integrating new libraries with
existing types really clean, and if I had some struct that implemented Read using ReadBytesExt would make those same functions available
on my type!&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;
&lt;p&gt;The result of this work is some really gorgeous eye-candy! To celebrate Rust’s 1.0 release I’ve rendered a Rust logo model made by 
&lt;a href=&quot;http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo&quot;&gt;Nylithius on BlenderArtists&lt;/a&gt; with a few different materials
and with some friends from the computer graphics community: the Buddha and Dragon from the
&lt;a href=&quot;http://graphics.stanford.edu/data/3Dscanrep/&quot;&gt;Stanford 3D Scanning repository&lt;/a&gt;. The Rust logo has 28,844 triangles, the version
of the Buddha I used has 1,087,474 triangles and the version of the Dragon has 871,306 triangles. The render times are
from a reasonably beefy machine we have at the lab with dual
&lt;a href=&quot;http://ark.intel.com/products/64583/Intel-Xeon-Processor-E5-2680-20M-Cache-2_70-GHz-8_00-GTs-Intel-QPI&quot;&gt;Xeon E5-2680’s @ 2.7GHz&lt;/a&gt;,
I ran tray_rust with 32 threads for these renders. There is also still a bug in my BVH construction which is leading
to less than optimal BVHs so I think these times could be improved a bit once I get that fixed. Area lights are also
still on my todo list so these scenes are just lit by a single point light and as such we don’t get any nice soft shadows.
Render times are formatted as hh:mm:ss along with the total time in milliseconds shown in parenthesis.&lt;/p&gt;

&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot; style=&quot;text-align:center&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/JouSgr5.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/JouSgr5.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;800x600, 1024 samples, using a black oxidized steel material. Render time: 00:09:00.208 (540208ms)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot; style=&quot;text-align:center&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/t3bLX9W.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/t3bLX9W.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;800x600, 1024 samples, using a two layer silver material. Render time: 00:08:53.74 (533727ms)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot; style=&quot;text-align:center&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/Wm2k6CI.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/Wm2k6CI.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;800x600, 1024 samples, using a black obsidian material. Render time: 00:08:58.33 (538330ms)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot; style=&quot;text-align:center&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/I4KSpzq.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/I4KSpzq.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;800x600, 1024 samples, using a brass material. Render time: 00:08:59.78 (539784ms)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot; style=&quot;text-align:center&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/fUEv6Au.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/fUEv6Au.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;800x600, 1024 samples, smallpt scene with specularly reflective and transparent spheres. Render time: 00:03:15.86 (195862ms)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;col-lg-12 col-md-12 col-xs-12&quot;&gt;
&lt;a href=&quot;http://i.imgur.com/9QU6fOU.png&quot;&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;http://i.imgur.com/9QU6fOU.png&quot; /&gt;&lt;/a&gt;
&lt;p&gt;1920x1080, 2048 samples. The Rust logo is using black oxidized steel, the Stanford Buddha
is using gold metallic paint and the Stanford Dragon is using blue acrylic. Render time: 01:13:52.13 (4432127ms)&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;There are still a few things left on my todo list for tray_rust. I need to fix my BVH construction so it doesn’t give some
poor quality splits, add support for area lights and make some kind of scene file format so that changing the scene doesn’t require
re-compiling. I’d also like to implement some more material models, I have a few nice microfacet based analytic models in tray
to port over and would like to add some sort of rough glass model. Materials with &lt;a href=&quot;http://en.wikipedia.org/wiki/Subsurface_scattering&quot;&gt;subsurface scattering&lt;/a&gt;
properties would also be really cool to implement. Depending on how much free time I find, I’ve also got some more advanced rendering
methods on my list such as bidirectional path tracing and &lt;a href=&quot;http://iliyan.com/publications/VertexMerging&quot;&gt;vertex connection and merging&lt;/a&gt;, a recently introduced
powerful and robust rendering approach that has seen fast adoption in commercial renderers. There are of course other methods
that are fun to work with as well, such as photon mapping and its variants, but I’m not sure how much more I want to add to tray_rust.
I’m definitely not aiming to implement something as massive and impressive as &lt;a href=&quot;https://www.mitsuba-renderer.org/&quot;&gt;Mitsuba&lt;/a&gt;,
which supports pretty much everything under the sun.&lt;/p&gt;

&lt;p&gt;After working with Rust for a longer period and following changes and development up to 1.0 more closely I’m pretty happy with the language,
and look forward to continuing to use it, though there are of course some complaints and annoyances I’ve run into. Good learning material
can be a bit hard to come by but this is being worked on and should be solid by 1.0. Compiler error messages can be a bit difficult to figure out
sometimes, especially relating to lifetime issues. Fortunately the community is very helpful in working through these and it sounds like this is on
the list of post-1.0 work. It’s also not possible at the moment to implement memory pool style patterns in Rust, something which I used extensively
in my C++ ray tracer. Compile times can be pretty slow, especially when compiling with optimization level 3 and link time optimization. Rust is still a young
language and I think all of these issues (and more) are on the &lt;a href=&quot;https://internals.rust-lang.org/t/priorities-after-1-0/1901&quot;&gt;priorities after 1.0&lt;/a&gt;
list and will be addressed in the future.&lt;/p&gt;

&lt;p&gt;If you have comments, suggestions for improvements or just want to say “hi” feel free to comment below, &lt;a href=&quot;https://twitter.com/_wusher&quot;&gt;tweet at me&lt;/a&gt;
or ping me on IRC (I’m Twinklebear on freenode and moznet).
The code for the Rust ray tracer is MIT licensed and available on &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="Rust" /><category term="ray tracing" /><category term="graphics" /><summary type="html">It’s been a little while since my last post on tray_rust as I’ve been a busy with classes, but I’ve had a bit of free time to implement some extremely cool features. In this post we’ll look at porting over the path tracing code and adding a bounding volume hierarchy, along with adding support for triangle meshes and measured material data from the MERL BRDF Database introduced by Matusik et al. in 2003 in A Data-Driven Reflectance Model. In the process of implementing the BVH we’ll get a taste of Rust’s generic programming facilities and use them to write a flexible BVH capable of storing any type that can report its bounds. In the spirit of fogleman’s gorgeous Go Gopher in Go we’ll wrap up by rendering the Rust logo in Rust using a model made by Nylithius on BlenderArtists. If you’ve been following Rust’s development a bit you have probably noticed that the timing of this post is not a coincidence, since Rust 1.0.0 is being released today!</summary></entry><entry><title type="html">Porting a Ray Tracer to Rust, part 2</title><link href="http://localhost:4000/2015/01/30/porting-a-ray-tracer-to-rust-part-2" rel="alternate" type="text/html" title="Porting a Ray Tracer to Rust, part 2" /><published>2015-01-30T00:00:00-07:00</published><updated>2015-01-30T00:00:00-07:00</updated><id>http://localhost:4000/2015/01/30/porting-a-ray-tracer-to-rust-part-2</id><content type="html" xml:base="http://localhost:4000/2015/01/30/porting-a-ray-tracer-to-rust-part-2">&lt;p&gt;As mentioned in my &lt;a href=&quot;/2014/12/30/porting-a-ray-tracer-to-rust-part-1&quot;&gt;previous post&lt;/a&gt; I spent the past month-ish
working on improving both the rendering capabilities and performance of &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt;.
While it’s not yet capable of path tracing we can at least have light and shadow and shade our objects with diffuse or specularly
reflective and/or transmissive materials. Along with this I’ve improved performance by parallelizing
the rendering process using Rust’s multithreading capabilities. Although ray tracing is a trivially parallel task there are
two pieces of state that must be shared and modified between threads: the pixel/block counter and the framebuffer.
With Rust’s strong focus on safety I was worried that I would have to resort to unsafe blocks to share these
small pieces of mutable state but I found that the &lt;a href=&quot;http://doc.rust-lang.org/std/sync/index.html&quot;&gt;std::sync module&lt;/a&gt;
provided safe methods for everything I needed and performs quite well. While it’s difficult to compare against
&lt;a href=&quot;https://github.com/Twinklebear/tray&quot;&gt;tray&lt;/a&gt; (my initial C++ version) as the design of tray_rust has diverged quite 
a bit I’ll put some performance numbers in the multithreading section.&lt;/p&gt;

&lt;p&gt;During the past month &lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; has also seen some pretty large changes and is currently
in its 1.0 alpha release with the &lt;a href=&quot;http://blog.rust-lang.org/2014/12/12/1.0-Timeline.html&quot;&gt;first beta&lt;/a&gt;
fast approaching.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;the-material-system&quot;&gt;The Material System&lt;/h2&gt;
&lt;p&gt;The material system used in &lt;a href=&quot;http://pbrt.org/&quot;&gt;PBRT&lt;/a&gt; makes heavy use of memory arenas to avoid making lots of small allocations of
the various BxDFs that the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bidirectional_scattering_distribution_function&quot;&gt;BSDF&lt;/a&gt; for the surface is
composed of during rendering. Instead large blocks of memory are allocated up front
and the small allocations needed during rendering are made by marking sections in these regions as used. The memory is re-used by
marking everything free again once we’ve finished tracing an eye ray since we don’t need to preserve any of this information across
primary rays. From some discussion in the &lt;a href=&quot;https://news.ycombinator.com/item?id=8818611&quot;&gt;Hacker News&lt;/a&gt; thread for part 1 it sounds like it isn’t
currently possible to implement a memory pool in Rust although it is being worked on. There is the
&lt;a href=&quot;http://doc.rust-lang.org/arena/index.html&quot;&gt;std::arena&lt;/a&gt; module but I’m not sure if it meets my
needs. It may be possible now to write something similar to the &lt;a href=&quot;https://github.com/Twinklebear/tray/blob/master/include/memory_pool.h&quot;&gt;memory pool&lt;/a&gt;
I used in tray based off the implementation of the generic Arena allocator in std::arena,
I’ll have to investigate further. Do let me know if you have any thoughts in this area!&lt;/p&gt;

&lt;p&gt;To get around this for now without introducing a lot of allocations during rendering I chose to have the materials allocate a Vec of
their BxDFs when they’re created and then return BSDFs that just refer to these BxDFs. We do still need to allocate a BSDF
on the stack each time and return it (via moving) when getting the surface properties for an object but this isn’t too
expensive.&lt;/p&gt;

&lt;h4 id=&quot;working-with-bxdfs-using-iterators&quot;&gt;Working with BxDFs using Iterators&lt;/h4&gt;

&lt;p&gt;Since a surface’s properties can be defined through a combination of BxDFs we need to consider contributions from all of them
to determine the color of the surface when shading some intersection. Additionally we need to filter them
to only consider those that are relevant to the current lighting calculation, eg. if we’re computing reflected light we wouldn’t want to
waste time evaluating transmissive BxDFs. Using the &lt;a href=&quot;http://doc.rust-lang.org/std/iter/index.html&quot;&gt;std::iter&lt;/a&gt; module we can perform these
operations cleanly and safely without running into any bounds checking overhead that we would have when accessing a Vec
by index. As a simple example the following snippet returns the number of BxDFs that match some set of BxDF type flags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;num_matching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnumSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BxDFType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.bxdfs&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A more interesting example is taken from the &lt;code class=&quot;highlighter-rouge&quot;&gt;BSDF::eval&lt;/code&gt; method. This method computes the contribution of all BxDFs
for some pair of incident and outgoing light directions and returns the total color.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.bxdfs&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.filter_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.fold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Colorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;broadcast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s worth mentioning that the current BSDF implementation is incredibly naive, since the only currently supported materials are
either diffuse, specularly reflective or specularly reflective and transmissive they only have a single component
per light interaction (reflection or transmission) and we can get away without doing any random sampling of
the BSDF components. When path tracing is implemented and more complex materials are added this will have to be fixed, however
it won’t change the above code listing by much.&lt;/p&gt;

&lt;p&gt;Iterators combined with lambdas and closures make for some very powerful functionality. Similar expressions
can of course be written in C++11/14 using lambdas and the corresponding methods from the
&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm&quot;&gt;algorithms library&lt;/a&gt;, although I’m not sure if there’s similar functionality
to filter and filter_map provided by the C++ standard library.&lt;/p&gt;

&lt;p&gt;If we take a slight tangent away from materials for a moment, we find that we can even express the operation of checking
a ray for intersection with all the instances of geometry in the scene
as a fold operation! By capturing the ray as a mutable borrow in the closure and modifying its max_t member after each
intersection we can use the following to find the nearest intersection and return it, or None if nothing was hit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;/// Test the ray for intersections against the objects in the scene.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/// Returns Some(Intersection) if an intersection was found and None if not.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intersection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// We can always return the next hit found since the ray's max_t value is updated&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// after an intersection is found. Thus if we find another hit we know that one&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// occured before any previous ones.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.instances&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.fold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                    &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Edit 1/31/15&lt;/strong&gt;: &lt;a href=&quot;https://www.reddit.com/r/rust/comments/2u8jtd/porting_a_ray_tracer_to_rust_part_2/co6onlx&quot;&gt;/u/Veedrac&lt;/a&gt; pointed
out that we could make the intersection code even clearer using the &lt;a href=&quot;http://doc.rust-lang.org/std/option/enum.Option.html#method.or&quot;&gt;or&lt;/a&gt; method
of Option, I’ve updated the code to now be:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.instances&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.fold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this method I’ve also chosen a fix for the &lt;a href=&quot;/2014/12/30/porting-a-ray-tracer-to-rust-part-1/#a-poor-design-choice&quot;&gt;poor design decision&lt;/a&gt;
I made last time. Following from some helpful discussion in the comments
on part 1, Reddit, Hacker News and IRC I’ve made the Geometry trait and Instance struct return different types from their intersect methods
and will instead implement the BVH to take types that implement a Boundable trait. Traversal will then be done by
returning an iterator that traverses the BVH and iterates over all potentially intersected
objects. The caller can then perform whatever operations it likes over the objects returned by the iterator, be it intersection testing on
Geometry or Instances or anything really.&lt;/p&gt;

&lt;h2 id=&quot;parallelism&quot;&gt;Parallelism&lt;/h2&gt;
&lt;p&gt;While ray tracing is an extremely easy problem to parallelize there’s still room for some interesting implementations, and I think
the one I’ve gone with is pretty neat and leaves the door open for even more fun. It’s possible to
write a ray tracer that doesn’t do any synchronization by assigning threads their work up front and having them only write to disjoint regions
of the framebuffer, but this design doesn’t do a very good job of load balancing (what if one thread gets all the hard pixels?)
and makes it very difficult to implement &lt;a href=&quot;http://www.luxrender.net/wiki/LuxRender_Render_settings#Filter&quot;&gt;reconstruction filtering&lt;/a&gt;
(now samples affect adjacent pixels as well, and the regions are no longer disjoint). To have a robust and high quality
renderer it’s worth it to support this minimal level of synchronization between threads, to avoid hurting performance too much
this synchronization should be kept as lightweight as possible, ideally using only atomics.&lt;/p&gt;

&lt;p&gt;In tray I followed PBRT and implemented the framebuffer using atomic floats with C++’s &lt;code class=&quot;highlighter-rouge&quot;&gt;std::atomic&amp;lt;float&amp;gt;&lt;/code&gt; type, updating pixel values
using compare exchange loops. This same method is also possible to implement in Rust by either directly using the LLVM intrinsics
or working through the &lt;a href=&quot;http://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt; type to create an atomic float
identical to &lt;code class=&quot;highlighter-rouge&quot;&gt;std::atomic&amp;lt;float&amp;gt;&lt;/code&gt;. To implement the atomic float method I would still need to write some minor bits of unsafe code to
transmute the bits of the float to a usize to go through AtomicUsize, so I decided to try Rust’s safe lock-free multi-producer
single-consumer channel in &lt;a href=&quot;http://doc.rust-lang.org/std/sync/mpsc/&quot;&gt;std::sync::mpsc&lt;/a&gt; first,
as this wouldn’t require any unsafe code on my end. I still chose to divide up work in the same way I did previously with an array
of block start positions which are indexed by an atomic uint (AtomicUsize in Rust), each thread just does a fetch add to find
the next block to work on and returns when there are none left.&lt;/p&gt;

&lt;p&gt;To render the scene I spawn a number of worker threads and hand each of them a send end of the mpsc channel where they will write
their sample results, sending the x, y position and color of the sample. The receive end of the channel is held onto by the
main thread which reads samples from the channel and writes them to the framebuffer until all send ends have closed. This implementation
provides some interesting trade-offs with the atomic float framebuffer method, instead of conflicting on every channel of the
pixel (RGB and weight) threads will only conflict on the two atomics in the channel when trying to send their samples.
However if we aren’t doing reconstruction filtering then the threads in the atomic float method never conflict and just pay the cost
of a few atomic operations while in the channel implementation threads will conflict since they’re all still writing
to the same channel. Another option I didn’t look into yet is to give each thread their own channel to write to and use select to
read samples as they come in from each channel. If this would also be lock-free from the sender side then it’s possible this is
an even better implementation since the worker threads don’t actually need to care about each others samples since they
aren’t writing them to the framebuffer. I’d be interested to hear other people’s thoughts on this implementation.&lt;/p&gt;

&lt;p&gt;The mpsc channel implementation does perform quite nicely, using 8 worker threads on my desktop with an i7-4790K @ 4GHz we
can render the &lt;a href=&quot;http://www.kevinbeason.com/smallpt/&quot;&gt;smallpt scene&lt;/a&gt; with one sample per pixel in 144ms! What’s even more exciting about the channel
implementation is that it easily extends to support rendering across multiple machines on a network.
Each thread on the worker machines would send their samples to a network thread which would batch up samples and send them to the master machine
instead of directly to a framebuffer thread. These samples would then be received either by the master’s framebuffer thread directly or
picked up on a network thread and sent through the same mpsc channel used by the worker threads. The overhead of setting up the network
and communicating samples would probably take much more time than rendering our scene with a simple Whitted
integrator but will be worth pursuing once path tracing is implemented. The code for the worker and framebuffer threads is located in
&lt;a href=&quot;https://github.com/Twinklebear/tray_rust/blob/master/src/main.rs&quot;&gt;main.rs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/o7VKbBq.png&quot; class=&quot;img-fluid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are a few stray black/white pixels in the image but I think these are just sampling artifacts and should be cleaned up once we
start taking more than one sample per pixel. Here we’re just hitting an uncommon path where we get a black or white
result, at least that’s what I hope is the case.&lt;/p&gt;

&lt;p&gt;This version is also run without any architecture specific optimizations (to my knowledge) such as taking advantage of any available
SIMD instructions like you would get when compiling C or C++ with &lt;code class=&quot;highlighter-rouge&quot;&gt;-march=native&lt;/code&gt;. There is a flag to pass to rustc to
enable these optimizations however I’m not sure how to pass it to rustc through Cargo.
It looks to currently be an open issue, &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/544&quot;&gt;#544&lt;/a&gt; and
&lt;a href=&quot;https://github.com/rust-lang/cargo/issues/1137&quot;&gt;#1137&lt;/a&gt;, if it is possible now please do let me know.
I’d expect at least some performance gain with the use of auto-vectorization and SSE/AVX instructions.&lt;/p&gt;

&lt;h4 id=&quot;sharing-immutable-data-between-threads&quot;&gt;Sharing Immutable Data Between Threads&lt;/h4&gt;
&lt;p&gt;In a ray tracer we also need to share some immutable data between threads so that they all know what scene they’re rendering.
In Rust this is done with atomic reference counted pointers using the &lt;a href=&quot;http://doc.rust-lang.org/std/sync/struct.Arc.html&quot;&gt;Arc&lt;/a&gt;
struct. This works pretty nicely although I ran into some minor annoyances. Currently if you want to put a trait in an Arc
it must be in a Box as well, even though the Arc has it’s own box (this may have changed with unsized types, see below).
That is to say if we had a trait Geometry and we wanted to share some instance between threads we can’t currently write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// This doesn't work!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Sphere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Instead we must box the sphere first&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geom_correct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Sphere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Additionally it’s not possible to immutably borrow an object across multiple threads even if it can be proven that the object
being borrowed outlives all the threads. From what I’ve been told both of these issues are being worked on, the Arc&amp;lt;Trait&amp;gt;
type might actually be possible now with unsized types but I’ve had some difficulty finding reading material on how to use these.
If anyone has a link to a good write-up on unsized types it’d be much appreciated, or I’ll bug folks in IRC for info about it.
As for sharing Arcs vs. immutable borrows (what I did in the C++ version) I think I prefer using Arcs even though both
methods should be valid to write in the language eventually. Note that we don’t have any overhead from updating the reference
count during rendering since we can immutably borrow within the thread to refer to hit geometry and instances.&lt;/p&gt;

&lt;h2 id=&quot;managing-dependencies-with-cargo&quot;&gt;Managing Dependencies with Cargo&lt;/h2&gt;
&lt;p&gt;In addition to helping build your project, its docs, and run tests &lt;a href=&quot;https://crates.io/&quot;&gt;Cargo&lt;/a&gt; is also a powerful dependency
management tool. During some of the updates to Rust the more experimental and niche modules such as EnumSet got moved
out into &lt;a href=&quot;https://github.com/Gankro/collect-rs&quot;&gt;collect-rs&lt;/a&gt;, getting this crate and linking my project was really easy to do
by adding the &lt;a href=&quot;https://crates.io/crates/collect&quot;&gt;package&lt;/a&gt; as a dependency with Cargo. It’s also possible to depend on git repositories
as I’ve done with &lt;a href=&quot;https://github.com/PistonDevelopers/image&quot;&gt;image&lt;/a&gt; by specifying a git dependency, so now tray_rust can output
PNG and JPEG images!&lt;/p&gt;

&lt;p&gt;For executables Cargo also locks the versions of your dependencies so others trying to build your project will build with the same versions
of the libraries you’re building with, making it smoother to build other people’s packages and programs. It even works well on
Windows which is always a bit of a hassle when trying to manage C or C++ dependencies. Rust is still quite young and the
ecosystem is very small compared to C and C++ so the comparison isn’t really fair but I’m hopeful that Cargo will
keep dependency management painless even as the ecosystem grows.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;After working with Rust for longer I’m pretty happy with how the language is shaping up. To name a few features I
had fun with over the past month, match expressions and the powerful iterator module are really nice to work with.
The community is also very friendly and helpful, the Rust IRC and subreddit have been great resources over
the past month and &lt;a href=&quot;http://this-week-in-rust.org/&quot;&gt;This Week in Rust&lt;/a&gt; is invaluable when keeping up with
changes in the nightlies or just finding cool Rust related write-ups and discussion.&lt;/p&gt;

&lt;h4 id=&quot;until-next-time&quot;&gt;Until Next Time&lt;/h4&gt;
&lt;p&gt;For part 3 I’ll work on getting a proper path tracing implementation running and fix some lingering bugs in the current
code that I’ve worked around to render the scene for this post. I’ll also take a look at the performance of giving
each thread its own channel vs. a shared mpsc and possibilities for rendering across multiple machines.
Path tracing will need much more compute power to render the scene quickly and networked rendering should be really fun to play with.&lt;/p&gt;

&lt;p&gt;If you have comments, suggestions for improvements or just want to say “hi” feel free to comment below, &lt;a href=&quot;https://twitter.com/_wusher&quot;&gt;tweet at me&lt;/a&gt;
or ping me on IRC (I’m Twinklebear on freenode and moznet).
The code for the Rust ray tracer is MIT licensed and available on &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;Github&lt;/a&gt;.&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="Rust" /><category term="ray tracing" /><category term="graphics" /><summary type="html">As mentioned in my previous post I spent the past month-ish working on improving both the rendering capabilities and performance of tray_rust. While it’s not yet capable of path tracing we can at least have light and shadow and shade our objects with diffuse or specularly reflective and/or transmissive materials. Along with this I’ve improved performance by parallelizing the rendering process using Rust’s multithreading capabilities. Although ray tracing is a trivially parallel task there are two pieces of state that must be shared and modified between threads: the pixel/block counter and the framebuffer. With Rust’s strong focus on safety I was worried that I would have to resort to unsafe blocks to share these small pieces of mutable state but I found that the std::sync module provided safe methods for everything I needed and performs quite well. While it’s difficult to compare against tray (my initial C++ version) as the design of tray_rust has diverged quite a bit I’ll put some performance numbers in the multithreading section. During the past month Rust has also seen some pretty large changes and is currently in its 1.0 alpha release with the first beta fast approaching.</summary></entry><entry><title type="html">Porting a Ray Tracer to Rust, part 1</title><link href="http://localhost:4000/2014/12/30/porting-a-ray-tracer-to-rust-part-1" rel="alternate" type="text/html" title="Porting a Ray Tracer to Rust, part 1" /><published>2014-12-30T00:00:00-07:00</published><updated>2014-12-30T00:00:00-07:00</updated><id>http://localhost:4000/2014/12/30/porting-a-ray-tracer-to-rust-part-1</id><content type="html" xml:base="http://localhost:4000/2014/12/30/porting-a-ray-tracer-to-rust-part-1">&lt;p&gt;I’ve decided to port over my physically based ray tracer &lt;a href=&quot;https://github.com/Twinklebear/tray&quot;&gt;tray&lt;/a&gt;
to &lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; to finally try out the language with a decent sized project.
In the series we’ll work through the implementation of a physically based ray tracer built
on the techniques discussed in &lt;a href=&quot;http://pbrt.org/&quot;&gt;Physically Based Rendering&lt;/a&gt;. I won’t go into a lot of
detail about rendering theory or the less exciting implementation details but will focus more on Rust
specific concerns and implementation decisions along with comparisons vs. my C++ version.
If you’re looking to learn more about ray tracing I highly recommend picking up Physically
Based Rendering and working through it. Hopefully throughout the series folks more experienced
with Rust can point out mistakes and improvements as well, since I have no experience with Rust
prior to this series.&lt;/p&gt;

&lt;p&gt;With the intro out of the way, let’s get started! Since it’s the beginning of
the series this is my first time really working with Rust and our goal is pretty simple: render a white
sphere and save the image.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;the-linear-algebra-module&quot;&gt;The Linear Algebra Module&lt;/h2&gt;
&lt;p&gt;I started by porting the linear algebra module used by tray over, since almost everything else
we do in the ray tracer will need basic linear algebra operations. This was pretty straightforward
but I did run into a few minor annoyances with things in the current state of Rust,
&lt;code class=&quot;highlighter-rouge&quot;&gt;rustc 0.13.0-nightly (636663172 2014-12-28 16:21:58 +0000)&lt;/code&gt;, namely: lack of function overloading
, default parameters and operator overloading for both left and right multiplication.&lt;/p&gt;

&lt;h4 id=&quot;function-overloading&quot;&gt;Function Overloading&lt;/h4&gt;
&lt;p&gt;This is a feature I used extensively throughout the C++ version of the ray tracer which helps
make things a bit more ergonomic. I first ran into this when implementing my vector type. In
tray I have overloads for the constructor so that it can be constructed with x, y and z all set
independently or by setting them all to the same value, as below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is convenient as there are many times when you simply want a vector that’s initialized
to all 0 or 1 for example. Since function overloading isn’t currently supported in Rust
these two methods require different names, I chose &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt; for my single value constructor.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;broadcast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’d really prefer to just have an overload of &lt;code class=&quot;highlighter-rouge&quot;&gt;new(x: f32) -&amp;gt; Vector&lt;/code&gt; which performed the same
construction that &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt; does currently, although this is a relatively minor annoyance.&lt;/p&gt;

&lt;h4 id=&quot;default-parameters&quot;&gt;Default Parameters&lt;/h4&gt;
&lt;p&gt;This relates closely to function overloading in that it also simplifies commonly written calls, eg. my
C++ vector constructors also default to set the values to 0, so constructing a vector of all 0
values is simply &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector{}&lt;/code&gt;. This doesn’t seem to be currently in Rust, but is another (somewhat minor)
feature that would be nice to have.&lt;/p&gt;

&lt;h4 id=&quot;overloading-left-and-right-multiply&quot;&gt;Overloading Left and Right Multiply&lt;/h4&gt;
&lt;p&gt;While it was very easy to overload the vector * scalar operator, writing the same overload
for scalar * vector doesn’t seem to be possible (please let me know if this has changed!). On the
topic of operator overloading, I do really like Rust’s decision to make them traits
because they can then be set as requirements for generic functions.
Below is my vector * scalar overload, it’s two extra lines than in C++ but is very clear to read.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit (12/31/14)&lt;/strong&gt;: &lt;a href=&quot;https://www.reddit.com/r/rust/comments/2qvs4z/porting_a_ray_tracer_to_rust_part_1/cnaaep&quot;&gt;ben0x539&lt;/a&gt;
mentioned that unsupported left-multiply overloading is a &lt;a href=&quot;https://github.com/rust-lang/rust/issues/19035&quot;&gt;bug&lt;/a&gt;
which may be getting fixed in &lt;a href=&quot;https://github.com/rust-lang/rust/pull/19434&quot;&gt;19434&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Edit (5/9/15)&lt;/strong&gt;: Overloading left and right multiply is now supported in Rust. Additionally the method
for writing overloaded operators has changed significantly with the addition of associated types. The
current implementation of right and left multiply for &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt; are now:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;// Multiply a vector by a f32 on the right, eg. `vec * 2.0`&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// Scale the vector by some value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Multiply a f32 by a vector on the right, eg. `2.0 * vec`&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// Scale the vector by some value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because operator overloading is done through traits we can set constraints on generic
functions to require that the types being worked on implement certain operations. This makes
the function clearer than in C++ (eg. what types it takes) and also gives much better compilation
errors when types not implementing the required operations are passed. For an extremely simple
comparison lets look at the C++ and Rust implementations of &lt;code class=&quot;highlighter-rouge&quot;&gt;lerp&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lerp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we misuse the lerp implementation in C++ we get a decent amount of errors. gcc-4.9
is quite clear about what went wrong, but these errors are shown as occuring inside the
function call (since that’s the point of error) and would be harder to parse for more complex functions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;test.cpp: In instantiation of ‘T lerp(float, const T&amp;amp;, const T&amp;amp;) [with T = Foo]’:
test.cpp:10:32:   required from here
test.cpp:3:30: error: no match for ‘operator*’ (operand types are ‘float’ and ‘const Foo’)
     return (1.f - t) * a + t * b;
                              ^
test.cpp:3:22: error: no match for ‘operator*’ (operand types are ‘float’ and ‘const Foo’)
     return (1.f - t) * a + t * b;
                      ^
test.cpp: In function ‘T lerp(float, const T&amp;amp;, const T&amp;amp;) [with T = Foo]’:
test.cpp:4:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a user glancing through some template code in C++ it may not be clear what operations and functions
the type must provide (although for a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;lerp&lt;/code&gt; it is). Rust solves this by allowing you
to specify requirements on the traits implemented by the types. In &lt;code class=&quot;highlighter-rouge&quot;&gt;lerp&lt;/code&gt; we need to be able
to multiply the types by floats, add the types to each other and make a copy of them to return.
Specifying these requirements up front makes the function interface much clearer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lerp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we misuse the lerp implementation in Rust we get some pretty clear and helpful errors,
telling us why the error occured and what we should do to resolve it. The error messages also
point us to the location of the bad call, which is much more useful than being pointed at a problem
inside some template function.
Note that in C++ we also didn’t get any errors about the lack of &lt;code class=&quot;highlighter-rouge&quot;&gt;operator+&lt;/code&gt;, which we’d get next
if we fixed our missing &lt;code class=&quot;highlighter-rouge&quot;&gt;operator*&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tray_rust/src/main.rs:11:15: 11:27 error: the trait `core::kinds::Copy` is not implemented for the type `Foo`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);
                                                                ^~~~~~~~~~~~
tray_rust/src/main.rs:11:15: 11:27 note: the trait `core::kinds::Copy` must be implemented because it is required by `tray_rust::linalg::lerp`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);
                                                                ^~~~~~~~~~~~
tray_rust/src/main.rs:11:15: 11:27 error: the trait `core::ops::Add&amp;lt;Foo, Foo&amp;gt;` is not implemented for the type `Foo`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);
                                                                ^~~~~~~~~~~~
tray_rust/src/main.rs:11:15: 11:27 note: the trait `core::ops::Add` must be implemented because it is required by `tray_rust::linalg::lerp`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);
                                                                ^~~~~~~~~~~~
tray_rust/src/main.rs:11:15: 11:27 error: the trait `core::ops::Mul&amp;lt;f32, Foo&amp;gt;` is not implemented for the type `Foo`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);
                                                                ^~~~~~~~~~~~
tray_rust/src/main.rs:11:15: 11:27 note: the trait `core::ops::Mul` must be implemented because it is required by `tray_rust::linalg::lerp`
tray_rust/src/main.rs:11     let awd = linalg::lerp(0.5, &amp;amp;Foo, &amp;amp;Foo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;C++ also provides default implementations of the copy constructor for types while Rust does not,
thus in Rust we must require that &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; is implemented for the type. I think Rust’s decision to not 
provide copy by default is a good one as it can cause trouble if you forget to delete the
copy constructor and copy-assign operators in C++ and your
type should not be copied. For most types that should be copyable that I’ve worked with so far
it’s simple enough to just use a compiler generated implementation via &lt;code class=&quot;highlighter-rouge&quot;&gt;#[deriving(Copy)]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;rusts-module-system&quot;&gt;Rust’s Module System&lt;/h2&gt;
&lt;p&gt;In tray I chose to split up the various components of the ray tracer into their own libraries
which are then statically linked into the main executable.
This design is also possible in Rust by splitting functionality up into
independent modules. I had some difficulty initially understanding how to work with modules
and how inter-module dependencies worked but after reading through the
&lt;a href=&quot;http://doc.rust-lang.org/guide-crates.html&quot;&gt;guide&lt;/a&gt; the end result is very nice. tray_rust is organized
with most functionality implemented in separate modules that are
built into a library and used by &lt;code class=&quot;highlighter-rouge&quot;&gt;main.rs&lt;/code&gt; to render the image.&lt;/p&gt;

&lt;p&gt;Under &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; I have the default executable and library files, &lt;code class=&quot;highlighter-rouge&quot;&gt;main.rs&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lib.rs&lt;/code&gt;. Also under &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;
are the various module subdirectories, eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg&lt;/code&gt; for the linear algebra module, each containing
a &lt;code class=&quot;highlighter-rouge&quot;&gt;mod.rs&lt;/code&gt; which defines some module level functions and re-exports the sub-modules implementing
other functionality, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt; module in &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg&lt;/code&gt;. The end result of this is that I can
have a very simple &lt;code class=&quot;highlighter-rouge&quot;&gt;lib.rs&lt;/code&gt; which just publicly exports the various modules:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;main.rs&lt;/code&gt; I can then tell Rust I need to build and link against the default library crate for
the executable, &lt;code class=&quot;highlighter-rouge&quot;&gt;tray_rust&lt;/code&gt; which is defined by &lt;code class=&quot;highlighter-rouge&quot;&gt;lib.rs&lt;/code&gt;, and use the modules:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello! {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Inter-module dependencies and circular dependencies are also handled very nicely. In the geometry module
if I need access to some of the types in &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg&lt;/code&gt; I can simply &lt;code class=&quot;highlighter-rouge&quot;&gt;use linalg;&lt;/code&gt; and not need to worry about
dealing with fiddly link order requirements. Circular dependencies
aren’t a problem at all, which is nice coming from C++ where they can be a bit annoying, requiring
forward declarations and such.&lt;/p&gt;

&lt;h4 id=&quot;re-exporting-from-modules&quot;&gt;Re-exporting From Modules&lt;/h4&gt;
&lt;p&gt;I initially struggled with the sheer amount of typing required for some of the nested modules. Since my
&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt; struct is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt; module within the &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg&lt;/code&gt; module to access it I would have to type
&lt;code class=&quot;highlighter-rouge&quot;&gt;linalg::vector::Vector&lt;/code&gt;, which is a mouthful. While important to avoid naming conflicts I thought this
was pretty excessive and after some googling stumbled onto &lt;a href=&quot;http://stackoverflow.com/questions/22596920/rust-splitting-a-single-module-across-several-files&quot;&gt;re-exporting from modules&lt;/a&gt;. This lets
us re-export the &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt; type from the &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg&lt;/code&gt; module allowing us to use it as &lt;code class=&quot;highlighter-rouge&quot;&gt;linalg::Vector&lt;/code&gt;,
which I think is more than enough to avoid name conflicts. This is done in the linalg module file,
&lt;code class=&quot;highlighter-rouge&quot;&gt;linalg/mod.rs&lt;/code&gt; where we export the various sub-modules and re-export their types:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;working-with-traits&quot;&gt;Working With Traits&lt;/h2&gt;
&lt;p&gt;In my C++ ray tracer geometry is defined by an interface that provides methods such as &lt;code class=&quot;highlighter-rouge&quot;&gt;intersect&lt;/code&gt; which
tests a ray for intersection with some piece of geometry, making it very easy to add new geometry types
to the ray tracer by implementing the interface. Additionally we separate the definition of some
geometry with its occurance in the
scene, so that a single model may appear multiple times in the scene with different materials and
transformations, a method known as instancing. To keep things simple when implementing our bounding
volume hierarchy our instance type also implements the geometry interface, simply transformating the
ray into object space and then calling the geometry’s intersect method.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This technique carries over directly to Rust in the form of traits. Instead of providing a base class
with pure virtual methods like we’d do in C++ we define a &lt;code class=&quot;highlighter-rouge&quot;&gt;Geometry&lt;/code&gt; trait that provides these
same methods and write implementations for our geometry such as our Sphere type.
Below is the geometry trait implemented by the various scene geometry types in tray_rust.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersect&lt;/code&gt; has an interesting return type, which lets me talk about another cool feature of Rust: no
null pointers! Instead Rust defines an &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type which can be either &lt;code class=&quot;highlighter-rouge&quot;&gt;Some(T)&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; and
both cases must be considered. In C++ (and C, Java, etc) it’s easy to ignore the possibility that
a pointer may be null resulting in seg faults, null pointer exceptions and more. Rust avoids the &lt;a href=&quot;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&quot;&gt;billion
dollar mistake&lt;/a&gt;
by forcing you to not be &lt;a href=&quot;http://arthurtw.github.io/2014/12/21/rust-anti-sloppy-programming-language.html&quot;&gt;sloppy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my C++ version I would take the DifferentialGeometry as a mutable reference and return a
bool if the ray intersected the object, filling out the differential geometry with the hit info if it
hit. In Rust this is expressed much cleaner, if there’s a hit we return &lt;code class=&quot;highlighter-rouge&quot;&gt;Some(DifferentialGeometry)&lt;/code&gt;
otherwise we simply return &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;. The DifferentialGeometry also needs to send back information about
the instance and geometry that was hit, leading to the next topic: lifetimes in Rust.&lt;/p&gt;

&lt;h2 id=&quot;lifetimes-in-rust&quot;&gt;Lifetimes in Rust&lt;/h2&gt;
&lt;p&gt;The concept and enforcement of &lt;a href=&quot;http://doc.rust-lang.org/guide-ownership.html&quot;&gt;ownership&lt;/a&gt; in Rust
was one of the features that initially got me interested in the language. For the most part lifetimes
are implicit in the language, however sometimes the compiler needs some assistance deducing lifetimes
for some variables. I first encountered this when writing my &lt;code class=&quot;highlighter-rouge&quot;&gt;DifferentialGeometry&lt;/code&gt; struct which needs
to return back references to the hit &lt;code class=&quot;highlighter-rouge&quot;&gt;Geometry&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Instance&lt;/code&gt; so we can shade the hit point properly.
In order to verify the code is valid the compiler needs to check that the geometry and instance
referenced by the differential geometry will not be outlived by the differential geometry, as this
would result in dangling references. To specify this separate lifetime on a struct we’d write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// This isn't quite correct yet!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;error-explicit-lifetime-bound-required&quot;&gt;Error: Explicit Lifetime Bound Required&lt;/h4&gt;
&lt;p&gt;Writing the above &lt;code class=&quot;highlighter-rouge&quot;&gt;geom&lt;/code&gt; member resulted in the most difficult error message I encountered
so far in Rust. Attempting to compile the above results in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;src/geometry/differential_geometry.rs:17:19: 17:27 error: explicit lifetime bound required
src/geometry/differential_geometry.rs:17     pub geom: &amp;amp;'a Geometry,
                                                           ^~~~~~~~&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The message is actually quite clear, if I knew what an explicit lifetime bound was. However it
doesn’t seem to be mentioned in the guides which is what made resolving this error
much more challenging than previous ones. After a decent amount of googling I
found that while the way I wrote &lt;code class=&quot;highlighter-rouge&quot;&gt;geom&lt;/code&gt; is correct for a regular struct a trait
requires an explicit lifetime bound since the type of data being referenced is unknown (we only know
it implements the trait). This is resolved by bounding the lifetime with
&lt;code class=&quot;highlighter-rouge&quot;&gt;Geometry + 'a&lt;/code&gt; and the correct form is:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’d like to find some more information on what exactly this means, such as
what a lifetime bound tells the compiler and how it’s used. Unfortunately I didn’t have much luck finding
information on this, if anyone has some links please do let me know.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit (12/31/14)&lt;/strong&gt;: &lt;a href=&quot;https://twitter.com/JakeGoulding&quot;&gt;@JakeGoulding&lt;/a&gt; pointed me to one of his answers
on &lt;a href=&quot;http://stackoverflow.com/questions/27675554/type-definition-with-a-trait-differences-of-specifying-an-explicit-lifetime-bou/27678350#27678350&quot;&gt;stack overflow&lt;/a&gt; which I found to be helpful.
Another &lt;a href=&quot;http://stackoverflow.com/questions/26212397/rust-lang-references-to-traits-in-structs/26213294#26213294&quot;&gt;answer&lt;/a&gt; linked in the thread also has a really nice explanation. As a result of reading the
answers I’ve changed the geom member’s type to &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;'a (Geometry + 'static)&lt;/code&gt; to require the object
implementing the trait that we’re referring to be a struct, since we won’t be implementing Geometry
for reference types.&lt;/p&gt;

&lt;h4 id=&quot;a-poor-design-choice&quot;&gt;A Poor Design Choice&lt;/h4&gt;
&lt;p&gt;The DifferentialGeometry struct also contains a design decision that I’m not very happy with.
The differential geometry is initially created within the geometry that was hit, since it doesn’t know
about the instance that is using it that was hit it’s not able to set the instance member. This
results in the instance member of DifferentialGeometry having to be written as an optional reference,
when really it’s not optional. Any geometry we hit is associated with an instance, it’s just that
we don’t know which at the time of hitting the geometry itself, we need to go back up the call stack to
the instance that called the geometry’s intersect method.
This results in the DifferentialGeometry struct being written as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within the Sphere’s implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;Geometry::intersect&lt;/code&gt; we know the geometry and hit information
but not the instance and thus if the sphere is intersected we return:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then in the instance using the geometry we see that it was hit and transform
the DifferentialGeometry back into world space and set the instance:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DifferentialGeometry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.inv_transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.geom&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.max_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.max_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.ng&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.ng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One option is to give Instance its own intersect method and have the Geometry intersect function
just return back the hit point information and have the Instance fill out the geometry and instance
references. This isn’t such a good option though since it breaks the illusion that instances are just
geometry and will cause trouble when trying to write a bounding volume hierarchy that we can put
the instances in the scene into and can also use to construct BVHs on triangle meshes to accelerate
intersection testing.&lt;/p&gt;

&lt;p&gt;As far as the end user of the intersect call is concerned there will always be a geometry and instance
reference on the DifferentialGeometry returned but I’m not sure how to express this. Another possibility
would be to have another Intersection type which didn’t have the option and could be constructed
from an &lt;code class=&quot;highlighter-rouge&quot;&gt;Option&amp;lt;DifferentialGeometry&amp;gt;&lt;/code&gt; and would return &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; if the DifferentialGeometry or the
instance was &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; (although the latter wouldn’t happen), otherwise it would unwrap the instance
member’s option and return &lt;code class=&quot;highlighter-rouge&quot;&gt;Some&amp;lt;Intersection&amp;gt;&lt;/code&gt;. I’ll probably look into implementing this as the
cleanest solution I can think of even though it’s really just a band-aid. If anyone has some ideas
or suggestions, please leave a comment or get in touch on &lt;a href=&quot;https://twitter.com/_wusher&quot;&gt;Twitter&lt;/a&gt;
or IRC (I’m Twinklebear on freenode and moznet).&lt;/p&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Rust also has built in support for specifying &lt;a href=&quot;http://doc.rust-lang.org/guide-testing.html&quot;&gt;tests and benchmarks&lt;/a&gt; by placing &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;#[bench]&lt;/code&gt; attributes respectively. These are then run using
&lt;a href=&quot;https://crates.io/&quot;&gt;Cargo&lt;/a&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo test&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo bench&lt;/code&gt;. This built in support makes it very 
easy to write and run unit and integration tests for your code and is really convenient coming from
C++ where testing is done through third party libraries.&lt;/p&gt;

&lt;h2 id=&quot;rustdoc&quot;&gt;Rustdoc&lt;/h2&gt;
&lt;p&gt;Rust comes with a built in &lt;a href=&quot;http://doc.rust-lang.org/rustdoc.html&quot;&gt;documentation generation tool&lt;/a&gt;
that makes it really easy to have nice documentation for both the language and user libraries by
just running &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo doc&lt;/code&gt; on your crate. Since the generated doc site is all static pages it’s simple
to host them on &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github pages&lt;/a&gt; or browse them locally.
For example here is the rustdoc for this &lt;a href=&quot;http://www.willusher.io/tray_rust/tray_rust/&quot;&gt;project&lt;/a&gt;.
Good documentation is critical for any library or decent sized project and having it standardized
and built into the
language like this will hopefully improve the overall quality of documentation for user libraries.&lt;/p&gt;

&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting it all Together&lt;/h2&gt;
&lt;p&gt;Now that we’ve got modules to handle &lt;a href=&quot;https://github.com/Twinklebear/tray_rust/tree/master/src/linalg&quot;&gt;linear algebra&lt;/a&gt;, &lt;a href=&quot;https://github.com/Twinklebear/tray_rust/tree/master/src/geometry&quot;&gt;geometry&lt;/a&gt; and &lt;a href=&quot;https://github.com/Twinklebear/tray_rust/tree/master/src/film&quot;&gt;camera/image operations&lt;/a&gt; we have everything
we need to render a sphere! In &lt;code class=&quot;highlighter-rouge&quot;&gt;main.rs&lt;/code&gt; we create our render
target, camera and sphere then attach the sphere to an instance and loop over the pixels in the image,
firing rays through each and checking for intersections:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tray_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;800u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;RenderTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;look_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;40.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.dimensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sphere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Sphere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;geometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sphere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;linalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;px&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;f32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.generate_ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Colorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;broadcast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;film&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write_ppm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;out.ppm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The executable and library modules are built and the executable run with &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo run&lt;/code&gt;.
While the resulting image isn’t very impressive, we’re well on our way to writing a flexible
physically based ray tracer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/fO5GVbt.png&quot; class=&quot;img-fluid&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;While I did encounter some minor annoyances with Rust I’m really happy with how the language
is shaping up as it nears 1.0 and look forward to the 1.0 release. One other difference compared
to C++ I didn’t mention is that variables in Rust are immutable by default and must be explicitly
declared mutable whereas C++ defaults to mutable variables.
I think Rust’s decision of immutable by default is great, most of the time I find that I really only
need a few mutable variables in my programs while everything else is constant or locally constant
and used to compute other constant results or operate on the few mutable variables.&lt;/p&gt;

&lt;h4 id=&quot;until-next-time&quot;&gt;Until Next Time&lt;/h4&gt;
&lt;p&gt;In the next post I’ll discuss the process of making tray_rust multithreaded and adding support
for some simple materials and lights which we’ll then render using Whitted recursive ray tracing.
While this ray tracing method doesn’t account for global illumination like path tracing or photon
mapping it’s simple to implement and very fast and will help us develop and test our abstractions
for integrators, materials and lights.&lt;/p&gt;

&lt;p&gt;If you have comments, suggestions for improvements or just want to say “hi” feel free to comment below,
or contact me on &lt;a href=&quot;https://twitter.com/_wusher&quot;&gt;Twitter&lt;/a&gt; or IRC (I’m Twinklebear on freenode and moznet).
The code for the Rust ray tracer is MIT licensed and available on &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;Github&lt;/a&gt;.&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="Rust" /><category term="ray tracing" /><category term="graphics" /><summary type="html">I’ve decided to port over my physically based ray tracer tray to Rust to finally try out the language with a decent sized project. In the series we’ll work through the implementation of a physically based ray tracer built on the techniques discussed in Physically Based Rendering. I won’t go into a lot of detail about rendering theory or the less exciting implementation details but will focus more on Rust specific concerns and implementation decisions along with comparisons vs. my C++ version. If you’re looking to learn more about ray tracing I highly recommend picking up Physically Based Rendering and working through it. Hopefully throughout the series folks more experienced with Rust can point out mistakes and improvements as well, since I have no experience with Rust prior to this series. With the intro out of the way, let’s get started! Since it’s the beginning of the series this is my first time really working with Rust and our goal is pretty simple: render a white sphere and save the image.</summary></entry><entry><title type="html">Postscript 1: Easy Cleanup</title><link href="http://localhost:4000/sdl2%20tutorials/2014/08/01/postscript-1-easy-cleanup" rel="alternate" type="text/html" title="Postscript 1: Easy Cleanup" /><published>2014-08-01T00:00:00-06:00</published><updated>2014-08-01T00:00:00-06:00</updated><id>http://localhost:4000/sdl2%20tutorials/2014/08/01/postscript-1-easy-cleanup</id><content type="html" xml:base="http://localhost:4000/sdl2%20tutorials/2014/08/01/postscript-1-easy-cleanup">&lt;p&gt;In this quick postscript we’ll look into a simple way to clean up our various SDL resources with variadic templates
and template specialization. This will let us clean up all our resources with a single simple call:
&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup(texA, texB, renderer, window)&lt;/code&gt; instead of calling all the corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Destroy/Free*&lt;/code&gt; functions,
saving ourselves a lot of typing.&lt;/p&gt;

&lt;p&gt;We’ll do this by creating a variadic function &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; that will take the list of SDL resources to be free’d and then
define specializations of it for each resource we’ll be passing, eg. for &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Window&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Renderer&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Texture&lt;/code&gt;
and so on.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;the-variadic-cleanup-function&quot;&gt;The Variadic Cleanup Function&lt;/h2&gt;
&lt;p&gt;If you’re unfamiliar with the C++11’s &lt;a href=&quot;http://en.wikipedia.org/wiki/Variadic_template&quot;&gt;varidic templates&lt;/a&gt; and
&lt;a href=&quot;http://thbecker.net/articles/rvalue_references/section_01.html&quot;&gt;rvalue references and forwarding&lt;/a&gt; features it may be useful
to do some reading to get some background before continuing on to the implementation. The implementation
of our cleanup function however is actually quite simple. We have a single variadic template function that
calls one of our specialized cleanup functions and then recurses to iterate through the list of arguments.
Since the code for this functionality is so short I’ve left the detailed explanations in the comments, so be sure to
read through them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef CLEANUP_H
#define CLEANUP_H
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;utility&amp;gt;
#include &amp;lt;SDL.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * Recurse through the list of arguments to clean up, cleaning up
 * the first one in the list each iteration.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//Cleanup the first item in the list
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//Recurse to clean up the remaining arguments
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * These specializations serve to free the passed argument and also provide the
 * base cases for the recursive call above, eg. when args is only a single item
 * one of the specializations below will be called by
 * cleanup(std::forward&amp;lt;Args&amp;gt;(args)...), ending the recursion
 * We also make it safe to pass nullptrs to handle situations where we
 * don't want to bother finding out which values failed to load (and thus are null)
 * but rather just want to clean everything up and let cleanup sort it out
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Window&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SDL_DestroyWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Renderer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Renderer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ren&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ren&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SDL_DestroyRenderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ren&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Texture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Texture&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SDL_DestroyTexture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Surface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Surface&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SDL_FreeSurface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;using-the-variadic-cleanup-function&quot;&gt;Using the Variadic Cleanup Function&lt;/h2&gt;
&lt;p&gt;To see the usefulness of this cleanup utility let’s see how it compresses our calls to the various
&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Destroy/Free*&lt;/code&gt; functions throughout &lt;a href=&quot;/sdl2%20tutorials/2013/08/17/lesson-1-hello-world&quot;&gt;Lesson 1&lt;/a&gt;.
In lesson 1 if we found that our bitmap or texture wasn’t created successfully we’d need to destroy
the renderer and window before quitting out of SDL and exiting with a failure code. With &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt;
we can compress these two lines down to a single call.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//We compress these two lines down
//SDL_DestroyRenderer(ren);
//SDL_DestroyWindow(win);
//to a single cleanup call:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ren&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;We can also compress the three lines used to free all the resources (texture, renderer and window) at the end of
Lesson 1 down into a single &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; call, passing all the resources we want to free.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//We compress these three lines down
//SDL_DestroyTexture(tex);
//SDL_DestroyRenderer(ren);
//SDL_DestroyWindow(win);
//to a single cleanup call:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ren&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; can also be used as a drop-in replacement for the various &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Destroy/Free*&lt;/code&gt; functions, although this
doesn’t really give us much benefit as far as compressing lines goes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//Cleanup can also swap in for direct calls turning
//SDL_FreeSurface(bmp);
//into
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;end-of-postscript&quot;&gt;End of Postscript&lt;/h2&gt;
&lt;p&gt;That’s all for this postscript, try out &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; yourself by converting your code from Lesson 1 to use it instead of
calling all the &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Destroy/Free*&lt;/code&gt; functions manually. If you run into any issues or have any questions
please post a comment below.&lt;/p&gt;

&lt;p&gt;I’ll see you again soon in
&lt;a href=&quot;/sdl2%20tutorials/2013/08/17/lesson-2-dont-put-everything-in-main&quot;&gt;Lesson 2: Don’t Put Everything in Main&lt;/a&gt;!&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="SDL2 Tutorials" /><category term="SDL2" /><summary type="html">In this quick postscript we’ll look into a simple way to clean up our various SDL resources with variadic templates and template specialization. This will let us clean up all our resources with a single simple call: cleanup(texA, texB, renderer, window) instead of calling all the corresponding SDL_Destroy/Free* functions, saving ourselves a lot of typing. We’ll do this by creating a variadic function cleanup that will take the list of SDL resources to be free’d and then define specializations of it for each resource we’ll be passing, eg. for SDL_Window, SDL_Renderer, SDL_Texture and so on.</summary></entry><entry><title type="html">Postscript 0: Properly Finding Resource Paths</title><link href="http://localhost:4000/sdl2%20tutorials/2014/06/16/postscript-0-properly-finding-resource-paths" rel="alternate" type="text/html" title="Postscript 0: Properly Finding Resource Paths" /><published>2014-06-16T00:00:00-06:00</published><updated>2014-06-16T00:00:00-06:00</updated><id>http://localhost:4000/sdl2%20tutorials/2014/06/16/postscript-0-properly-finding-resource-paths</id><content type="html" xml:base="http://localhost:4000/sdl2%20tutorials/2014/06/16/postscript-0-properly-finding-resource-paths">&lt;p&gt;In this short postscript we’ll learn how to make use of &lt;a href=&quot;https://wiki.libsdl.org/SDL_GetBasePath&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_GetBasePath&lt;/code&gt;&lt;/a&gt; to
properly resolve the path to our resource directory where we’ll be storing all the assets needed for each lesson.
This approach lets us avoid issues with relative paths since it doesn’t depend on where the program working
directory is set when it’s run. This functionality was introduced in SDL 2.0.1 so if you haven’t updated to the latest SDL
be sure to grab that before getting started.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;lesson-directory-structure&quot;&gt;Lesson Directory Structure&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_GetBasePath&lt;/code&gt; will return the path to the directory where the application executable is, so to properly find the resource
directory we’ll have to know how to change this path to get the resource directory path. For the lessons I’ll be using
the directory structure below, if you’re using a different directory structure you’ll likely need to make some
modifications to how the resource path is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Lessons/
    bin/
        executables in here
    res/
        Lesson1/
            Lesson 1's assets are stored here
    Lesson1/
        src/
            Lesson 1's source code
    include/
        Headers shared between lessons&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;getting-the-resource-path&quot;&gt;Getting the Resource Path&lt;/h2&gt;
&lt;p&gt;We’ll now write a convenient utility header containing the &lt;code class=&quot;highlighter-rouge&quot;&gt;getResourcePath&lt;/code&gt; function which will be used to resolve
the resource path based on the folder structure above. The function will also take a subdirectory name to be
appended to the path so we can then get the Lesson1 resource directory with &lt;code class=&quot;highlighter-rouge&quot;&gt;getResourcePath(&quot;Lesson1&quot;)&lt;/code&gt;. The code
below is placed into the shared include directory and named res_path.h in my code. The comments throughout the code
provide more detail on what’s going on so be sure to read through them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef RES_PATH_H
#define RES_PATH_H
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;SDL.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * Get the resource path for resources located in res/subDir
 * It's assumed the project directory is structured like:
 * bin/
 *  the executable
 * res/
 *  Lesson1/
 *  Lesson2/
 *
 * Paths returned will be Lessons/res/subDir
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getResourcePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//We need to choose the path separator properly based on which
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//platform we're running on, since Windows uses a different
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//separator than most systems
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef _WIN32
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATH_SEP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\\'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATH_SEP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//This will hold the base resource path: Lessons/res/
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//We give it static lifetime so that we'll only need to call
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//SDL_GetBasePath once to get the executable path
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//SDL_GetBasePath will return NULL if something went wrong in retrieving the path
&lt;/span&gt;		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SDL_GetBasePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;SDL_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Error getting resource path: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SDL_GetError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//We replace the last bin/ with res/ to get the the resource path
&lt;/span&gt;		&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rfind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bin&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;res&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATH_SEP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//If we want a specific subdirectory path in the resource directory
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//append it to the base path. This would be something like Lessons/res/Lesson0
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATH_SEP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;using-the-resource-path-lookup&quot;&gt;Using the Resource Path Lookup&lt;/h2&gt;
&lt;p&gt;With our new utility function we can easily construct the resource path for our programs and no longer need to rely
on relative paths and the various hassles that come with them. To get access to this new header in our shared include
directory we’ll need to add the directory &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; to our include path.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CMake&lt;/strong&gt;: In your top level CMakeLists file add &lt;code class=&quot;highlighter-rouge&quot;&gt;include_directories(include)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Visual Studio&lt;/strong&gt;: Add the include directory through your project preferences, similar to how you set the SDL2
include directories.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GCC and Clang&lt;/strong&gt;: Use the &lt;code class=&quot;highlighter-rouge&quot;&gt;-I&lt;/code&gt; flag to add the directory to your include path, eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;-Iinclude&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll now write a simple program that will print out the resource directory path to make sure everything is working correctly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;SDL.h&amp;gt;
#include &quot;res_path.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_INIT_EVERYTHING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SDL_Init error: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SDL_GetError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Resource path is: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getResourcePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;SDL_Quit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;end-of-postscript&quot;&gt;End of Postscript&lt;/h2&gt;
&lt;p&gt;You’ll want to double check that the path output by the test program is correct as we’ll be using &lt;code class=&quot;highlighter-rouge&quot;&gt;getResourcePath&lt;/code&gt; extensively
throughout the lessons to reliably find the various images and other assets we need for our programs. A related function
provided by SDL is &lt;a href=&quot;https://wiki.libsdl.org/SDL_GetPrefPath&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_GetPrefPath&lt;/code&gt;&lt;/a&gt; which returns the path where your application
can write personal files (save games, etc.).&lt;/p&gt;

&lt;p&gt;I’ll see you again soon in &lt;a href=&quot;/sdl2%20tutorials/2013/08/17/lesson-1-hello-world&quot;&gt;Lesson 1: Hello World!&lt;/a&gt;&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="SDL2 Tutorials" /><category term="SDL2" /><summary type="html">In this short postscript we’ll learn how to make use of SDL_GetBasePath to properly resolve the path to our resource directory where we’ll be storing all the assets needed for each lesson. This approach lets us avoid issues with relative paths since it doesn’t depend on where the program working directory is set when it’s run. This functionality was introduced in SDL 2.0.1 so if you haven’t updated to the latest SDL be sure to grab that before getting started.</summary></entry><entry><title type="html">Lesson 0: CMake</title><link href="http://localhost:4000/sdl2%20tutorials/2014/03/06/lesson-0-cmake" rel="alternate" type="text/html" title="Lesson 0: CMake" /><published>2014-03-06T00:00:00-07:00</published><updated>2014-03-06T00:00:00-07:00</updated><id>http://localhost:4000/sdl2%20tutorials/2014/03/06/lesson-0-cmake</id><content type="html" xml:base="http://localhost:4000/sdl2%20tutorials/2014/03/06/lesson-0-cmake">&lt;p&gt;CMake is really useful for building the lessons since it lets us generate make files or project files for just about
any platform and IDE. It also helps with resolving dependencies (such as SDL2), platform specific configurations and
much much more. If you’re unfamiliar with CMake there’s a nice introduction
available on &lt;a href=&quot;http://www.cmake.org/cmake/help/cmake_tutorial.html&quot;&gt;their site&lt;/a&gt; to help you get started.&lt;/p&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
&lt;b&gt;Windows users:&lt;/b&gt; Since Windows doesn't have any standardized include or library directories like Linux and OS X CMake
can have some trouble resolving dependencies, so we'll need to give it a hand. I've taken the existing FindSDL2
modules for CMake and have modified them a bit to also check for an environment variable named &lt;code&gt;SDL2&lt;/code&gt;. You should
create this environment variable and have it point to the root level of the folder containing the SDL2 headers
and libraries you downloaded previously.
&lt;/blockquote&gt;

&lt;p&gt;To lookup SDL2 we’ll need a module to find the dependency we want. Typically these are included in the CMake distribution
but for some newer libraries they may not be integrated yet. In the case of SDL2 we’ll need to provide our own module
to lookup the dependency. This module is available around online and in the lesson &lt;a href=&quot;https://github.com/Twinklebear/TwinklebearDev-Lessons/blob/master/cmake/FindSDL2.cmake&quot;&gt;repository&lt;/a&gt;. For Windows users I recommend using the modified version from the
repository since it will also check for your &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL2&lt;/code&gt; environment variable. The existing FindSDL2.cmake that’s floating
around will work for Linux and Mac but will likely fail to find the libraries on Windows.&lt;/p&gt;

&lt;h2 id=&quot;the-cmakeliststxt-files-for-our-project&quot;&gt;The CMakeLists.txt Files for Our Project&lt;/h2&gt;
&lt;p&gt;Our main CMakeLists file needs to do a few things so that we can build our project easily:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Append to the CMake module path so we can find our modified SDL2 modules.&lt;/li&gt;
  &lt;li&gt;Set an install directory (called &lt;code class=&quot;highlighter-rouge&quot;&gt;BIN_DIR&lt;/code&gt; here) that we can reference for installing our executables.&lt;/li&gt;
  &lt;li&gt;Find SDL2 and add the SDL2 include directory to the include path.&lt;/li&gt;
  &lt;li&gt;Add the Lesson0 subdirectory to find this lesson’s CMakeLists.txt so that we can build it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This CMakeLists.txt file should be in the top level directory of your project folder for the lessons.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot; data-lang=&quot;cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cmake_minimum_required&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;VERSION 2.6&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;TwinklebearDevLessons&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Use our modified FindSDL2* modules&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_MODULE_PATH &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_MODULE_PATH&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TwinklebearDevLessons_SOURCE_DIR&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/cmake&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Set an output directory for our binaries&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;BIN_DIR &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TwinklebearDevLessons_SOURCE_DIR&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;/bin&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Bump up warning levels appropriately for clang, gcc &amp;amp; msvc&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Also set debug/optimization flags depending on the build type. IDE users choose this when&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# selecting the build mode in their IDE&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_COMPILER_ID&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; STREQUAL &lt;span class=&quot;s2&quot;&gt;&quot;GNU&quot;&lt;/span&gt; OR &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_COMPILER_ID&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; STREQUAL &lt;span class=&quot;s2&quot;&gt;&quot;Clang&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_CXX_FLAGS &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; -Wall -Wextra -pedantic -std=c++11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_CXX_FLAGS_DEBUG &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS_DEBUG&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; -g&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_CXX_FLAGS_RELEASE &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS_RELEASE&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; -O2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;elseif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_COMPILER_ID&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; STREQUAL &lt;span class=&quot;s2&quot;&gt;&quot;MSVC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_CXX_FLAGS MATCHES &lt;span class=&quot;s2&quot;&gt;&quot;/W[0-4]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;nb&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;REGEX REPLACE &lt;span class=&quot;s2&quot;&gt;&quot;/W[0-4]&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/W4&quot;&lt;/span&gt; CMAKE_CXX_FLAGS &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_CXX_FLAGS &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; /W4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Look up SDL2 and add the include directory to our include path&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;find_package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;SDL2 REQUIRED&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SDL2_INCLUDE_DIR&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Look in the Lesson0 subdirectory to find its CMakeLists.txt so we can build the executable&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;add_subdirectory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;Lesson0&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-test-program&quot;&gt;The Test Program&lt;/h2&gt;
&lt;p&gt;The program we’re building for this lesson is a simple sanity check for SDL. It will 
&lt;a href=&quot;https://wiki.libsdl.org/SDL_Init&quot;&gt;initialize&lt;/a&gt; the SDL video subsystem, check for any
&lt;a href=&quot;https://wiki.libsdl.org/SDL_GetError&quot;&gt;errors&lt;/a&gt; and then &lt;a href=&quot;https://wiki.libsdl.org/SDL_Quit&quot;&gt;quit&lt;/a&gt;.
Our build system will look for this file under Lesson0/src/main.cpp.
If you place it elsewhere you’ll need to update the file names and subdirectories in the CMakeLists files.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;SDL.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * Lesson 0: Test to make sure SDL is setup properly
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDL_INIT_VIDEO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SDL_Init Error: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SDL_GetError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SDL_Quit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;To build our executable for Lesson0 we’ll need another CMakeLists.txt file within the Lesson0 directory, which our
main CMakeLists file will check since we’ve added the subdirectory to be searched. Here we just add an
executable to be built from our source file and tell CMake to link the executable against the SDL2 libraries.
We also add an install target to have the executable be installed to our binary directory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot; data-lang=&quot;cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;Lesson0&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;add_executable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;Lesson0 src/main.cpp&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;target_link_libraries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;Lesson0 &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SDL2_LIBRARY&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;TARGETS Lesson0 RUNTIME DESTINATION &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BIN_DIR&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;If you’ve been using the folder hierarchy used in the lessons you should now have something like this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;TwinklebearDevLessons/
    CMakeLists.txt
    Lesson0/
        CMakeLists.txt
        src/
            main.cpp
    cmake/
        FindSDL2.cmake&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;building-with-cmake&quot;&gt;Building With CMake&lt;/h2&gt;
&lt;p&gt;To build the project with CMake we’ll want to make a temporary build directory to store the various build artifacts so we
don’t pollute our source directory with a bunch of junk. From this folder we can then run &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake -G &quot;Your Generator&quot; ../&lt;/code&gt;
and CMake will generate makefiles or project files for &lt;code class=&quot;highlighter-rouge&quot;&gt;Your Generator&lt;/code&gt;. You can run &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake -H&lt;/code&gt; to see which generators
are available on your system. You can also specify the build type with &lt;code class=&quot;highlighter-rouge&quot;&gt;-DCMAKE_BUILD_TYPE=Type&lt;/code&gt;, passing Debug will
use the debug flags we set above and likewise for Release. I recommend building with the debug flags since it’ll make
it easier to track down problems with your debugger. A sample run of building a Unix Makefiles target 
in debug mode is shown below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mkdir build &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cmake -G &lt;span class=&quot;s2&quot;&gt;&quot;Unix Makefiles&quot;&lt;/span&gt; -DCMAKE_BUILD_TYPE&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Debug ../
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make install&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In this example regular Unix Makefiles will be generated in the build directory so the project can now be built
with make. Running &lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt; will install any targets we’ve specified (our Lesson0 binary) to their install
locations (&lt;code class=&quot;highlighter-rouge&quot;&gt;BIN_DIR&lt;/code&gt;). Windows users will also need to copy the relevant SDL2.dll to their install directory so
that the executables can find it. Be sure to copy the appropriate 32bit or 64bit dll depending on which you built.&lt;/p&gt;

&lt;h2 id=&quot;end-of-lesson-0&quot;&gt;End of Lesson 0&lt;/h2&gt;
&lt;p&gt;When we add more programs throughout the lesson series you can simply add the subdirectory with
&lt;code class=&quot;highlighter-rouge&quot;&gt;add_subdirectory(Lesson#)&lt;/code&gt; and then re-use the Lesson0 CMakeLists.txt file but replacing the occurances of
&lt;code class=&quot;highlighter-rouge&quot;&gt;Lesson0&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;Lesson#&lt;/code&gt;. When we start adding SDL extension libraries we’ll have to add some more CMake modules
and link targets but it’s pretty straightforward to setup.&lt;/p&gt;

&lt;p&gt;If you’re having any problems with the lesson please leave a comment below.&lt;/p&gt;

&lt;p&gt;I’ll see you again soon in &lt;a href=&quot;/sdl2%20tutorials/2014/06/16/postscript-0-properly-finding-resource-paths&quot;&gt;Postscript 0: Properly Finding Resource Paths!&lt;/a&gt;&lt;/p&gt;</content><author><name>Feng Wang</name><email>fwang911@gmail.com</email></author><category term="SDL2 Tutorials" /><category term="SDL2" /><category term="CMake" /><summary type="html">CMake is really useful for building the lessons since it lets us generate make files or project files for just about any platform and IDE. It also helps with resolving dependencies (such as SDL2), platform specific configurations and much much more. If you’re unfamiliar with CMake there’s a nice introduction available on their site to help you get started.</summary></entry></feed>